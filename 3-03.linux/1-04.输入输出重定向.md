## I/O redirect

-----

这堂课，我们来介绍可能是命令行最酷的特性。它叫做 `I/O` 重定向。`I/O` 代表输入/输出，通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。为了炫耀这个工具，我们将叙述以下命令：

> - cat  － 连接文件
> - sort － 排序文本行
> - uniq － 报道或省略重复行
> - grep － 打印匹配行
> - wc   － 打印文件中换行符，字，和字节个数
> - head － 输出文件第一部分
> - tail － 输出文件最后一部分

#### stdin\stdout\stderr

与 `Unix` 主题“任何东西都是一个文件”保持一致，程序实际上把他的运行结果输送到一个叫标准输出的特殊文件（常用 `stdout` 表示），而它们的状态信息则送到另一个叫做标准错误的文件（`stderr`）。

默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。此外，许多程序从一个叫做标准输入`（stdin）`的设备得到输入，默认情况下，标准输入连接到键盘。

| 文件描述符 | 缩写   | 描述         |
| ---------- | ------ | ------------ |
| 0          | STDIN  | 标准输入     |
| 1          | STDOUT | 标准输出     |
| 2          | STDERR | 标准错误输出 |

`I/O` 重定向允许我们可以更改输出走向和输入来向。一般地，输出送到屏幕，输入来自键盘， 但是通过 `I/O` 重定向，我们可以改变输入输出方向。

## stdout redirect `> >>`

-----

重定向标准输出到另一个文件除了屏幕，我们使用 `>` 重定向符，其后跟着文件名。例如，我们可以告诉 `shell` 把 `ls` 命令的运行结果输送到文件 `ls-output.txt` 中去， 由文件代替屏幕。

```bash
[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt
```

现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。

```bash
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt
ls: cannot access /bin/usr: No such file or directory
```

错误信息被送到标准错误。因为我们只是重定向了标准输出，而没有重定向标准错误， 所以错误信息被送到屏幕。马上，我们将知道怎样重定向标准错误，但是首先看一下我们的输出文件发生了什么事情。

```bash
me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me   me    0 2008-02-01 15:08 ls-output.txt
```

文件长度成为零！这是因为，当我们使用 `>` 重定向符来重定向输出结果时，目标文件总是从开头被重写。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容删除。**事实上，如果我们需要删除一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：**

```bash
[me@linuxbox ~]$ > ls-output.txt
```

所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用`>>`重定向符，如果文件不存在，文件会被创建，像这样：

```bash
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
```

## stderr redirect `2> 2>>`

-----

重定向标准错误缺乏专用的重定向操作符。一个程序可以在几个编号的文件流中的任一个上产生输出。然而我们必须把这些文件流的前三个看作标准输入，输出和错误，shell 内部参考它们为文件描述符0，1和2，各自地。shell 提供了一种表示法来重定向文件，使用文件描述符。因为标准错误和文件描述符2一样，我们用这种表示法来重定向标准错误：

```bash
[me@linuxbox ~]$ ls -l fuck 2> ls-error.txt
```

文件描述符`2`，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 `ls-error.txt` 任务。

## stdout&stderr redirect `2>&1 &>`

-----

可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法， 在旧版本 shell 中也有效：

```bash
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
```

使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符`2`（标准错误）到文件描述符1（标准输出）使用表示法`2>&1`。

```bash
[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt
```

现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。

## /dev/null

------

我们不想要一个命令的输出结果，只想把它们扔掉。系统为我们提供了解决问题的方法，通过重定向输出结果到一个特殊的叫做`/dev/null`的文件。这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：

```bash
[me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null
```

> **Unix 文化中的/dev/null**
>
> 位存储桶是个古老的 Unix 概念，由于它的普遍性，它的身影出现在 Unix 文化的许多部分。当有人说他/她正在发送你的评论到/dev/null，现在你应该知道那是什么意思了。

## to stdin

------

到目前为止，我们还没有遇到一个命令是利用标准输入的，所以我们需要介绍一下。

#### cat － 连接文件

cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样:

**命令格式：**

```bash
cat [file]
```

**基础使用：**

在大多数情况下，你可以使用 cat 来显示文件而没有分页，例如：

```bash
[me@linuxbox ~]$ cat ls-output.txt
```

**文件连接：**

因为 `cat` 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型文件，这个文件被分离成多个部分，我们想把它们连起来：

```bash
cat movie.mpeg.0* > movie.mpeg
```

**输入重定向：**

如果我们输入不带参数的 `cat` 命令，会发生什么呢：

```bash
[me@linuxbox ~]$ cat
```

没有发生任何事情，它只是坐在那里，好像挂掉了一样。看起来是那样，但是它正在做它该做的事情：

如果 `cat` 没有给任何参数，它会从标准输入读数据，因为标准输入默认情况下连接到键盘。 它正在等待我们输入数据！

```bash
[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
```

下一步，输入 `Ctrl-d`（按住 `Ctrl` 键同时按下 `d`），来告诉 `cat`，在标准输入中， 它已经到达文件末尾`EOF`：

```bash
[me@linuxbox ~]$ cat(Command+d)
The quick brown fox jumped over the lazy dog.
```

由于文件名参数的缺席，`cat` 复制标准输入到标准输出，所以我们看到文本行重复出现。 我们可以使用这种行为来创建简短的文本文件:

```bash
[me@linuxbox ~]$ cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

#### uniq  —  忽略重复行

`uniq` 命令经常和 `sort` 命令结合在一起使用。`uniq` 从标准输入或单个文件名参数 **接受数据有序列表默认情况下**，从数据列表中删除任何重复行。

**命令格式：**

```bash
uniq [file]
```

**基础使用：**

比如下面的 `repeated.txt` 里面就有两个重复行，使用 `uniq` 输出便可以过滤。

```bash
[root@inno linux]# uniq repeated.txt
repeated line
```

#### sort  —  排序

对输入的每一行进行排序。

**命令格式：**

```bash
sort [file]
```

**基础使用：**

比如下面的 `arr.txt` 里面就有三行 `1、3、2`，使用 `sort` 输出：

```bash
[root@inno linux]# sort arr.txt
1
2
3
```

#### wc － 打印行，字和字节数

`wc`（字计数）命令是用来显示文件所包含的行，字和字节数。

**命令格式：**

```bash
wc [file]
# -l：表示lines，行数
# -w：表示words，单词数   依照空格来判断单词数量
# -c：表示bytes，字节数 
```

**基础使用：**

```bash
➜ wc system.log
    4610   69677  836779 system.log
```

#### head / tail － 打印文件开头部分/结尾部分

有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。 `head` 命令打印文件的前十行，而 `tail` 命令打印文件的后十行。默认情况下，两个命令都打印十行文本，但是可以通过 `-n` 选项来调整命令打印的行数。

```bash
[me@linuxbox ~]$ head -n 5 ls-output.txt
total 343496
...
[me@linuxbox ~]$ tail -n 5 ls-output.txt
...
```

`tail` 有一个选项允许你实时的浏览文件。当观察日志文件的进展时，这很有用，因为它们同时在被写入。在以下的例子里，我们要查看目录 `/var/log` 里面的信息文件。

```bash
[me@linuxbox ~]$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
....
```

#### | —  管道线

命令可以从标准输入读取数据，然后再把数据输送到标准输出，命令的这种能力被 一个 shell 特性所利用，这个特性叫做管道线。使用管道操作符”|”（竖杠），一个命令的 标准输出可以管道到另一个命令的标准输入：

**命令格式：**

```bash
command1 | command2
```

**基础使用：**

比如`ls`命令把它的运行结果输送到`less`的标准输出：

```bash
[me@linuxbox ~]$ ls -l /usr/bin | less
```

**过滤器：**

管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。

我们添加 uniq 和sort 到我们的管道线中实现一个过滤的效果：

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
```

添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数， 我们可以这样做：

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```

`tail和head`它们也能用在管道线中：

```
[me@linuxbox ~]$ ls /usr/bin | tail -n 5
znew
...
```

#### tee  — 管道分流

`Linux` 提供了一个叫做 `tee` 的命令，这个命令制造了 一个 `tee`，安装到我们的管道上。`tee` 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时。

我们重复执行一个先前的例子， 这次包含 `tee` 命令，在 `grep` 过滤管道线的内容之前，来捕捉整个目录列表到文件 :

```bash
[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```