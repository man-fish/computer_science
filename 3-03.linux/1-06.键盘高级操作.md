## KeyBoard Skills

------

开玩笑地说，我经常把 Unix 描述为“这个操作系统是为喜欢敲键盘的人们服务的。” 当然，Unix 甚至还有一个命令行，这个事实是个确凿的证据，证明了我所说的话。 但是命令行用户不喜欢敲入那么多字。那又为什么如此多的命令会有这样简短的命令名，像 cp，ls，mv，和 rm？事实上，命令行最为珍视的目标之一就是懒惰；用最少的击键次数 来完成最多的工作。另一个目标是你的手指永远不必离开键盘，永不触摸鼠标。在这一 章节，我们将看一下 bash 特性，这些特性使键盘使用起来更加迅速，更加高效。

以下命令将会露面：

> - clear － 清空屏幕
> - history － 显示历史列表内容

`Bash` 使用了一个名为 `Readline` 的库（共享的线程集合，可以被不同的程序使用）， 来实现命令行编辑。我们已经看到一些例子。我们知道，例如，箭头按键可以移动鼠标， 此外还有许多特性。想想这些额外的工具，我们可以在工作中使用。学会所有的特性 并不重要，但许多特性非常有帮助。选择自己需要的特性。

> **注意：**下面一些按键组合（尤其使用 Alt 键的组合），可能会被 GUI 拦截来触发其它的功能。 当使用虚拟控制台时，所有的按键组合都应该正确地工作。

#### 移动光标

下表列出了移动光标所使用的按键：

表9-1: 光标移动命令

| 按键   | 行动                                 |
| :----- | :----------------------------------- |
| Ctrl-a | 移动光标到行首。                     |
| Ctrl-e | 移动光标到行尾。                     |
| Ctrl-f | 光标前移一个字符；和右箭头作用一样。 |
| Ctrl-b | 光标后移一个字符；和左箭头作用一样。 |

#### 修改文本

表9－2列出了键盘命令，这些命令用来在命令行中编辑字符。

表9-2: 文本编辑命令

| 按键   | 行动                                     |
| :----- | :--------------------------------------- |
| Ctrl-d | 删除光标位置的字符。                     |
| Ctrl-t | 光标位置的字符和光标前面的字符互换位置。 |

#### 剪切和粘贴文本

Readline 的文档使用术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。 剪切下来的本文被存储在一个叫做剪切环(kill-ring)的缓冲区中。

表9-3: 剪切和粘贴命令

| 按键          | 行动                                                         |
| :------------ | :----------------------------------------------------------- |
| Ctrl-k        | 剪切从光标位置到行尾的文本。                                 |
| Ctrl-u        | 剪切从光标位置到行首的文本。                                 |
| Ctrl-y        | 把剪切环中的文本粘贴到光标位置。                             |

#### 自动补全

shell 能帮助你的另一种方式是通过一种叫做自动补全的机制。当你敲入一个命令时， 按下 tab 键，自动补全就会发生。让我们看一下这是怎样工作的。给出一个看起来 像这样的家目录：

```bash
[me@linuxbox ~]$ ls
Desktop   ls-output.txt   Pictures   Templates   Videos
....
```

试着输入下面的命令，但不要按下 Enter 键：

```bash
[me@linuxbox ~]$ ls l
```

现在按下 tab 键：

```bash
[me@linuxbox ~]$ ls ls-output.txt
```

看一下 shell 是怎样补全这一行的？让我们再试试另一个例子。这回，也 不要按下 Enter:

```bash
[me@linuxbox ~]$ ls D
```

按下 tab:

```bash
[me@linuxbox ~]$ ls D
```

没有补全，只是嘟嘟响。因为”D”不止匹配目录中的一个条目。为了自动补全执行成功， 你给它的”线索”必须不模棱两可。如果我们继续输入：

```bash
[me@linuxbox ~]$ ls Do
```

然后按下 tab：

```bash
[me@linuxbox ~]$ ls Documents
```

自动补全成功了。

> **可编程自动补全:**
>
> 目前的 bash 版本有一个叫做可编程自动补全工具。可编程自动补全允许你（更可能是，你的 发行版提供商）来加入额外的自动补全规则。通常需要加入对特定应用程序的支持，来完成这个 任务。例如，有可能为一个命令的选项列表，或者一个应用程序支持的特殊文件类型加入自动补全。 默认情况下，Ubuntu 已经定义了一个相当大的规则集合。可编程自动补全是由 shell 函数实现的，shell 函数是一种小巧的 shell 脚本，我们会在后面的章节中讨论到。如果你感到好奇，试一下：
>

## History

------

正如我们在第二章中讨论到的，`bash` 维护着一个已经执行过的命令的历史列表。这个命令列表 被保存在你家目录下，一个叫做 `.bash_history` 的文件里。这个 `history` 工具是个有用资源， 因为它可以减少你敲键盘的次数，尤其当和命令行编辑联系起来时。

#### 搜索历史命令

在任何时候，我们都可以浏览历史列表的内容，通过：

```
[me@linuxbox ~]$ history | less
```

在默认情况下，bash 会存储你所输入的最后 500 个命令。在随后的章节里，我们会知道 怎样调整这个数值。比方说我们想要找到列出目录 /usr/bin 内容的命令。一种方法，我们可以这样做：

```
[me@linuxbox ~]$ history | grep /usr/bin
```

比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；

```
88  ls -l /usr/bin > ls-output.txt
```

数字 “88” 是这个命令在历史列表中的行号。随后在使用另一种展开类型时，叫做 历史命令展开，我们会用到这个数字。我们可以这样做，来使用我们所发现的行：

```
[me@linuxbox ~]$ !88
```

bash 会把 “!88” 展开成为历史列表中88行的内容。

#### history expand

通过使用 `!` 字符，`shell` 为历史列表中的命令，提供了一个特殊的展开类型。我们已经知道一个感叹号 ，其后再加上一个数字，可以把来自历史列表中的命令插入到命令行中。还有一些其它的展开特性：

表9-6: 历史展开命令

| 序列     | 行为                                                         |
| :------- | :----------------------------------------------------------- |
| !!       | 重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。 |
| !number  | 重复历史列表中第 number 行的命令。                           |
| !string  | 重复最近历史列表中，以这个字符串开头的命令。                 |
| !?string | 重复最近历史列表中，包含这个字符串的命令。                   |

应该小心谨慎地使用 “!string” 和 “!?string” 格式，除非你完全确信历史列表条目的内容。

> **脚本**
>
> 除了 bash 中的命令历史特性，许多 Linux 发行版包括一个叫做 script 的程序， 这个程序可以记录整个 shell 会话，并把 shell 会话存在一个文件里面。这个命令的基本语法是：
>
> **script [ file ]**
>
> 命令中的 file 是指用来存储 shell 会话记录的文件名。如果没有指定文件名，则使用文件 typescript。查看脚本的手册页，可以得到一个关于 script 程序选项和特点的完整列表。

