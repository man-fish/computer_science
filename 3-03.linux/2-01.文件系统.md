## file system

------

### linux and file

日常运维工作中，有近一半以上的工作内容精力其实都是对文件的操作。Linux 本身也是一个基于文件形式表示的操作系统。

![2015-06-23/558915847029a](file:///Users/inno/%E6%96%87%E6%A1%A3/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0%E4%B8%8B/61.linux/assets/2015-06-23_558915847029a.png?lastModify=1603251444)

把文件系统想象成一个迷宫形状，就像一棵倒立的大树，我们站在迷宫的中间位置。 在任意时刻，我们处于一个目录里面，我们能看到这个目录包含的所有文件， 以及通往上面目录（父目录）的路径，和下面的各个子目录。我们所在的目录则称为 当前工作目录。

**Linux一切皆文件。**

- 在windows是文件的，在Linux下同样也是文件；
- 在windows不是文件的，在Linux下也是以文件的形式存储的；

> **关于文件名的重要规则:**
>
> - 以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们， 用 ls -a 命令就可以了。
> - 文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的文件名。
> - Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任何名字 来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统， 不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。
> - 虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。**如果你想表示词与词间的空格，用下划线字符来代替**。过些时候，你会感激自己这样做。

### File Type

`Unix` 文件类型包括以下几种：

| 属性 | 文件类型                                                     |
| :--- | :----------------------------------------------------------- |
| -    | 一个普通文件                                                 |
| d    | 一个目录                                                     |
| l    | 一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性 |
| c    | 一个字符设备文件。这种文件类型是指按照字节流，来处理数据的设备。 比如说终端机，或者调制解调器 |
| p    | 一个先进先出队列的命名管道 |
| b    | 一个块设备文件。这种文件类型是指按照数据块，来处理数据的设备，例如一个硬盘，或者 CD-ROM 盘 |
|s|套接字 (socket)，主要用进程间的网络通信。|

### Directory Structure

在系统中游玩时，不要害怕粘花惹草。普通用户是很难把东西弄乱的。那是系统管理员的工作！ 如果一个命令抱怨一些事情，不要管它，尽管去玩别的东西。花一些时间四处走走。 系统是我们自己的，尽情地探究吧。记住在 Linux 中，没有秘密存在！ 表4-4仅仅列出了一些我们可以浏览的目录。闲暇时试试看！

| 目录           | 评论                                                         |
| :------------- | :----------------------------------------------------------- |
| /              | 根目录，万物起源。                                           |
| /bin           | 存放着最常用的二进制命令，可以直接调用。                     |
| /boot          | 包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和 启动加载程序。有趣的文件： /boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。 /boot/vmlinuz，Linux 内核。 |
| /dev           | Device，这是一个包含外部设备的特殊目录。“一切都是文件”，也使用于设备。 在这个目录里，内核维护着它支持的设备。 |
| /etc           | **这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会运行每个系统服务。 /etc/crontab， 定义自动运行的任务。 /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。** |
| /home          | 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通只能 在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib           | 包含核心系统程序所需的库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found    | 当恢复一个损坏的文件系统时，会用到这个目录。除非文件系统真正的损坏了，那么这个目录会是个空目录。 |
| /media         | 在现在的 Linux 系统中，/media 目录会包含可移除媒体设备的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt           | 该目录使用于用户挂载其他文件系统的时候挂载光驱使用。         |
| /opt           | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc          | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 反而，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root          | root 帐户的家目录。                                          |
| /sbin          | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp           | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次 重新启动时，都会清空这个目录。 |
| /usr           | **在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。** |
| /usr/bin       | **/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。** |
| /usr/lib       | 包含由/usr/bin 目录中的程序所用的共享库。                    |
| /usr/local     | **这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在这个目录， 但却是空目录，直到系统管理员放些东西到它里面。** |
| /usr/sbin      | **包含许多系统管理程序。**                                   |
| /usr/share     | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件，图标，桌面背景，音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var           | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录是可能需要经常改动的文件存储的地方。各种数据库，假脱机文件， 用户邮件等等，都驻扎在这里。 |
| /var/log       | 这个/var/log 目录包含日志文件，各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |

## File Sys Command

-----

### cd（change directory)

用于切换当前的工作目录的命令。

**语法：**

`#cd` 路径

**参数：**

- `cd ~` 切换到当前的用户目录
  - `cd ~USER_NAME` 切换 `USER_NAME` 的家目录。
- `cd ..` 切换到上级目录
- `cd -` 切换到上一个访问的目录
- `cd /` 切换到跟目录

```bash
cd /usr
# /usr 
```

### pwd (print working directory)

用于打印当前工作目录

**语法：**

`pwd`

```bash
➜ pwd
/Users/inno
```

### file (file)

在 `Linux` 系统中，并不要求文件名来反映文件的内容，我们通过 `file` 命令来确定文件的类型。

**语法：**

`file file`

```bash
[me@linuxbox ~]$ file picture.jpg
picture.jpg: JPEG image data, JFIF standard 1.01
```

### ls  (list)

有充分的理由证明，`ls` 可能是用户最常使用的命令。通过它，我们可以知道目录的内容，以及各种各样重要文件和目录的 属性。正如我们所知道的，只要简单的输入 `ls` 就能看到在当前目录下所包含的文件和子目录列表。

**选项：**

| —— | 长选项                           | 描述                                                         |
| :--- | :------------------------------- | :----------------------------------------------------------- |
| -a   | --all                            | 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 |
| -d   | --directory                      | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 |
| -F   | --classify                       | 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 |
| -h   | --human-readable                 | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 |
| -l   | 以长格式显示结果。               |                                                              |
| -r   | --reverse                        | 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 |
| -S   | 命令输出结果按照文件大小来排序。 |                                                              |
| -t   | 按照修改时间来排序。             |                                                              |

**使用：**

列出当前工作目录下的所有文件/文件夹的名称：

- 用法1：#ls 路径

```bash
➜ ls /usr
X11        X11R6      bin        lib        libexec    local
```

在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示：

- 用法2：#ls 选项 路径
  - 选项解释：
    -l：表示list，表示以详细列表的形式进行展示
     	-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）

```bash
➜ ls -al
total 4264
drwxr-xr-x+ 62 inno  staff     1984  2 16 19:12 .
drwxr-xr-x   5 root  admin      160 12  5 16:21 ..
-r--------   1 inno  staff        9  1 21 21:11 .CFUserTextEncoding
-rw-r--r--@  1 inno  staff    18436  2 16 18:18 .DS_Store
```

列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示

- 用法3：#ls -lh 路径

```bash
➜ ls -lh
total 3896
drwx------@  3 inno  staff    96B  1 26 17:37 Applications
drwx------@  4 inno  staff   128B  2  7 13:08 Desktop
drwx------@ 66 inno  staff   2.1K  1 22 22:14 Library
```

> **drwxr-xr-x**
>
> d：文件类型，rwx：所有者权限，r-x：同组权限，r-x：访客权限。
>
> - 第一列字符表示文档的类型，其中“-”表示改行对应的文档类型为文件，“d”表示文档类型为文件夹，“l”表示软连接。
>
> - 在Linux中隐藏文档一般都是以“.”开头。

### mkdir (make directory)

- 语法1：#mkdir 路径 【路径，可以是文件夹名称也可以是包含名称的一个完整路径】

```
~
➜ mkdir test
```

- 语法2：#mkdir -p 路径

- 含义：递归创建，当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错

```bash
~/test
➜ mkdir -p test1/test2

~/test
➜ ll
total 0
drwxr-xr-x  3 inno  staff    96B  2 16 19:30 test1
```

- 语法3：#mkdir 路径1 路径2 路径3 ….  【表示一次性创建多个目录】

```bash
~/test
➜ mkdir test4 test5

~/test
➜ ll
drwxr-xr-x  2 inno  staff    64B  2 16 19:31 test4
drwxr-xr-x  2 inno  staff    64B  2 16 19:31 test5
```

### touch   

- 作用：创建文件
- 语法：#touch 文件路径	【路径可以是直接的文件名也可以是路径】

```go
~/test
➜ touch /Users/inno/test/test.txt

~/test
➜ ll
total 0
-rw-r--r--  1 inno  staff     0B  2 16 19:32 test.txt
```

### cp  (copy)

这里列举了 cp 命令一些有用的选项（短选项和等效的长选项）：

|               选项 | 意义                                                         |
| -----------------: | :----------------------------------------------------------- |
|      -a, --archive | 复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。 |
| -i,  --interactive | 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。 |
|    -r, --recursive | 递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者-a 选项）。 |
|       -u, --update | 当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 |
|      -v, --verbose | 显示翔实的命令操作信息                                       |

- 作用：复制文件/文件夹到指定的位置
- 语法：#cp  被复制的文档路径 文档被复制到的路径

```bash
~/test
➜ cp test.txt test1

~/test
➜ ll test1
-rw-r--r--  1 inno  staff     0B  2 16 19:36 test.txt
```

- 语法：使用cp命令来复制一个文件夹
- 注意：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】，否则目录将被忽略

```bash
~/test
➜ cp -r test1 test4

~/test
➜ ll test4
total 0
drwxr-xr-x  4 inno  staff   128B  2 16 19:40 test1
```

**注意**：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。

```basg
~/test
➜ cp test.txt test

~/test
➜ ll
total 0
-rw-r--r--  1 inno  staff     0B  2 16 19:35 test
-rw-r--r--  1 inno  staff     0B  2 16 19:32 test.txt
```

### mv (move)

mv 与 cp 共享了很多一样的选项：

| 选项             | 意义                                                         |
| :--------------- | :----------------------------------------------------------- |
| -i --interactive | 在重写一个已经存在的文件之前，提示用户确认信息。 **如果不指定这个选项，mv 命令会默认重写文件内容。** |
| -u --update      | 当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。 |
| -v --verbose     | 当操作 mv 命令时，显示翔实的操作信息。                       |

- 作用：移动文档到新的位置
- 语法：#mv 需要移动的文档路径 需要保存的位置路径

```bash
~/test
➜ mv test test5

~/test
➜ ll test5
total 0
-rw-r--r--  1 inno  staff     0B  2 16 19:35 test
```

- 作用：使用mv来进行重命名文件。

```bash
~/test/test5
➜ mv test test111

~/test/test5
➜ ll
total 0
-rw-r--r--  1 inno  staff     0B  2 16 19:35 test111
```

- 作用：使用mv来重命名文件夹
- 注意：绝对路径、相对路径都可以

```bash
~/go/src
➜ mv $(pwd)/7days-golang $(pwd)/gee
```

### rm  (remove)

下表是一些普遍使用的 rm 选项：

| 选项            | 意义                                                         |
| :-------------- | :----------------------------------------------------------- |
| -r, --recursive | 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 |
| -f, --force     | 忽视不存在的文件，不显示提示信息。这选项颠覆了“--interactive”选项。 |

- 作用：移除/删除文档

- 语法：#rm 选项 需要移除的文档路径
  - 选项：
    - -f：force，强制删除，不提示是否删除
    - -r：表示递归

```bash
~
➜ rm -rf test
```

- 好用的命令：其中\*称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头的所有匹配项

```bash
~
➜ rm -rf /* 
```

> **注意：**
>
> 小心 rm！类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了。Linux 假定你很聪明，你知道你在做什么。尤其要小心通配符。
>
> 思考一下这个经典的例子。假如说，你只想删除一个目录中的 HTML 文件。输入：
>
> ```bash
> rm *.html
> ```
>
> 这是正确的，如果你不小心在 “*” 和 “.html” 之间多输入了一个空格，就像这样：
>
> ```bash
> rm * .html
> ```
>
> 这个 rm 命令会删除目录中的所有文件，还会抱怨没有文件叫做 “.html”。所以我们最好使用 ls 命令来测试通配符。这会让你看到要删除的文件列表。

### mkfifo (make fifo)

类似 `Unix` 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在两个进程之间建立连接，也可以像其它类型的文件一样使用。虽然它们不是那么流行，但是它们值得我们去了解。

命令管道的行为类似于文件，但实际上形成了先入先出 `FIFO` 的缓冲。和普通（未命令的）管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西：

```shell
process1 > named_pipe # put
process2 < named_pipe # get
```

表现出来就像这样：

```shell
process1 | process2
```

#### 设置一个命名管道

首先，我们必须创建一个命名管道。使用 `mkfifo` 命令能够创建命令管道：

```shell
[me@linuxbox ~]$ mkfifo pipe
[me@linuxbox ~]$ ls -l pipe
prw-r--r-- 1 me
me
0 2009-07-17 06:41 pipe1
```

#### 使用命名管道

为了演示命名管道是如何工作的，我们将需要两个终端窗口（或用两个虚拟控制台代替）。 在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道：

```shell
> ls -l > pipe1
```

我们按下 `Enter` 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。 使用第二个终端窗口，我们输入这个命令：

```shell
> cat < pipe1
```

然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 `cat` 命令的输出。在第一个终端 窗口中的 `ls` 命令一旦它不再阻塞，会成功地结束。