## echo

-----

当你按下 `enter` 键后，发生在命令行中的一些“魔法”。接下来我们用`echo`命令来描述这些"魔法"。

> - `echo` － 显示一行文本

让我们看一看 `echo` 命令。`echo` 是一个 `shell` 内部命令，它在标准输出中打印出它的文本参数。

```bash
echo this is a test
# this is a test
```

`echo -n` 删除 `echo` 结尾默认的换行符：

```shell
echo -n 'fuck you'
```

## expand

------

每一次你输入一个命令，然后按下 `enter` 键，在 `bash` 执行你的命令之前，`bash` 会对输入 的字符完成几个步骤处理。例如“`*`”, 对 `shell` 来说，有很多的涵义。使这个发生的过程叫做（字符）展开。通过展开，你输入的字符，在 `shell` 对它起作用之前，会展开成为别的字符。为了说明我们所要表达的意思：

```bash
echo *
# Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```

` shell` 把“`*`”展开成了 另外的东西（在这种情况下，就是在当前工作目录下的文件名），在 `echo` 命令被执行前。当回车键被按下时，`shell` 在命令被执行前在命令行上自动展开任何符合条件的字符， 所以 `echo` 命令从不会发现“`*`”,只把它展开成结果。

> **注意** 不管是在 `shell` 脚本中还是命令行中，展开都不能被单独使用，因为 `shell` 可能无法识别展开之后的字符而报错。

#### `*` expand

这种通配符工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧，我们会看到它们真是要展开的字符。给出一个家目录，它看起来像这样：

```bash
ls
# Desktop   ls-output.txt   Pictures   Templates
....
```

我们能够执行以下参数展开模式：

```bash
echo D*
# Desktop  Documents
```

和：

```bash
echo *s
# Documents Pictures Templates Videos
```

甚至是：

```bash
echo [[:upper:]]*
# Desktop Documents Music Pictures Public Templates Videos
```

查看家目录之外的目录：

```bash
echo /usr/*/share
# /usr/kerberos/share  /usr/local/share
```

> **隐藏文件路径名展开:**
>
> 正如我们知道的，以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种 行为。像这样的展开不会显示隐藏文件：
>
> ```bash
> echo * 
> ```
>
> 要是展开模式以一个圆点开头，我们就能够在展开模式中包含隐藏文件， 而且隐藏文件可能会出现在第一位置，就像这样：
>
> ```bash
>echo .*
> ```
> 
> 它几乎是起作用了。然而，如果我们仔细检查一下输出结果，我们会看到名字”.” 和”..”也出现在结果中。使用下面的命令可以忽略掉这两个值。
>
> ```bash
>ls -d .[!.]?*
> ```
> 

#### `~` expand

可能你从我们对 cd 命令的介绍中回想起来，波浪线字符(“`~`”)有特殊的意思。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则是当前用户的家目录：

```bash
cd ~
# /home/me
```

如果有用户”foo”这个帐号，然后：

```bash
echo ~foo
# /home/foo
```

#### `$((cal expression))` expand

shell 允许算术表达式通过展开来执行。这允许我们把 shell 提示当作计算器来使用：

```bash
echo $((2 + 2))
# 4
```

算术表达式展开使用这种格式：

```bash
$((expression))
```

（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。

算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。这里是 一些它支持的操作符：

表 8-1: 算术操作符

| 操作符 | 说明                                                       |
| :----- | :--------------------------------------------------------- |
| +      | 加                                                         |
| -      | 减                                                         |
| *      | 乘                                                         |
| /      | 除（但是记住，因为展开只是支持整数除法，所以结果是整数。） |
| %      | 取余，只是简单的意味着，“余数”                             |
| **     | 取幂                                                       |

#### `{}` expand

可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：

```bash
echo Front-{A,B,C}-Back
# Front-A-Back Front-B-Back Front-C-Back
```

花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能 嵌入空白字符。这个例题使用了一系列整数：

```bash
echo Number_{1..5}
# Number_1  Number_2  Number_3  Number_4  Number_5
```

一系列以倒序排列的字母：

```bash
echo {Z..A}
# Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
```

花括号展开可以嵌套：

```bash
echo a{A{1,2},B{3,4}}b
# aA1b aA2b aB3b aB4b
```

那么这对什么有好处呢？最普遍的应用是，创建一系列的文件或目录列表。例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，目录名按照 年代顺序排列。我们可以键入整个目录列表，但是工作量太大了，并且易于出错。 反而，我们可以这样做：

```bash
mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
ls
# 2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
# 2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
# 2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
# 2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
# 2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
# 2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
```

#### `$env` expand

在这一章我们将会简单地介绍参数展开，只是皮毛而已。后续章节我们会广泛地 讨论参数展开。这个特性在 shell 脚本中比直接在命令行中更有用。它的许多性能 和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更适当些应叫做变量，可以方便地检查它们。例如，叫做”USER”的变量包含你的 用户名。唤醒参数展开，揭示 USER 中的内容，可以这样做：

```bash
echo $USER
# me
```

查看有效的变量列表，试试这个：

```bash
printenv | less
```

你可能注意到其它展开类型，如果你误输入一个模式，展开就不会发生。这时 echo 命令只简单地显示误键入的模式。通过参数展开，如果你拼写错了一个变量名， 展开仍然会进行，只是展成一个空字符串：

```bash
echo $SUER
# patrick
```

#### `$(command)` expand

命令替换允许我们把一个命令的输出作为一个展开模式来使用：

```bash
echo $(ls)
# Desktop Documents ls-output.txt Music Pictures Public Templates
Videos
```

我最喜欢用的一行命令是像这样的：

```bash
ls -l $(which cp)
# -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

这里我们把 which cp 的执行结果作为一个参数传递给 ls 命令，因此要想得到 cp 程序的 输出列表，不必知道它完整的路径名。我们不只限制于简单命令。也可以使用整个管道线 （只展示部分输出）：

```bash
file $(ls /usr/bin/* | grep zip)
# /usr/bin/bunzip2:     symbolic link to `bzip2'
....
```

在这个例子中，管道线的输出结果成为 file 命令的参数列表。

在旧版 shell 程序中，有另一种语法也支持命令替换，可与刚提到的语发替换使用。 bash 也支持这种语法。它使用倒引号来代替美元符号和括号：

```bash
ls -l `which cp`
# -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

## expand controll

------

我们已经知道 shell 有许多方式可以完成展开，现在是时候学习怎样来控制展开了。 以下面例子来说明：

```bash
echo this is a    test
# this is a test
```

或者：

```bash 
echo The total is $100.00
# The total is 00.00
```

在第一个例子中，shell 从 echo 命令的参数列表中，删除多余的空格。在第二个例子中， 参数展开把 `$1` 的值替换为一个空字符串，因为 `1` 是没有定义的变量。shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。

#### 双引号

我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，除了 `$`，`\` (反斜杠），和 `（倒引号）之外， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开， 波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换 仍然执行。

使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 two words.txt 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：

```bash
ls -l two words.txt
# ls: cannot access two: No such file or directory
# ls: cannot access words.txt: No such file or directory
```

记住，在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：

```bash
echo "$USER $((2+2)) $(cal)"
# me 4    February 2008
# sSu Mo Tu We Th Fr Sa
....
```

我们应该花费一点时间来看一下双引号在命令替换中的效果。首先仔细研究一下单词分割 是怎样工作的。在之前的范例中，我们已经看到单词分割机制是怎样来删除文本中额外空格的：

```bash
echo this is a   test
# this is a test
```

事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个，虽然微妙，但有趣的影响。 考虑下面的例子：

```bash
echo $(cal)
# February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
# 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
echo "$(cal)"
# February 2008
....
```

在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。

#### 单引号

如果需要禁止所有的展开，我们使用单引号。以下例子是无引用，双引号，和单引号的比较结果：

```bash
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
# text /home/me/ls-output.txt a b foo 4 me
echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
# text ~/*.txt   {a,b} foo 4 me
echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
# text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
```

正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。

#### 转义字符

有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。

```bash
echo "The balance for user $USER is: \$5.00"
# The balance for user me is: $5.00
```

使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用 一些对于 shell 来说，有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名 中包含特殊字符，你可以这样做：

```bash
mv bad\&filename good_filename
```

为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符。

**反斜杠转义字符序列:**

反斜杠除了作为转义字符外，反斜杠也是一种表示法的一部分，这种表示法代表某种特殊字符，叫做控制码。ASCII 编码表中前32个字符被用来把命令转输到像电报机一样的设备。

一些编码是众所周知的（制表符，退格符，换行符，和回车符），其它 一些编码就不熟悉了（空值，传输结束码，和确认）。


| 转义字符| 含义 |
|------|-------|
| \a | 响铃警告－导致计算机嘟嘟响    		 	  |
| \b | 退格符														|
| \n | 新的一行。在类 Unix 系统中，产生换行。 |
| \r | 回车符 														|
| \t | 制表符 														|

> **fancy skill**
>
> echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $' ' 里面。 以下例子，使用 sleep 命令，一个简单的程序，它会等待指定的秒数，然后退出。 我们可以创建一个简单的倒数计数器：
>
> ```bash
> sleep 10; echo -e "Time's up\a"
> ```
>