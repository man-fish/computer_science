## 多进程

------

通常，现在的操作系统都支持多任务，意味着操作系统（给用户）造成了一种假象，(让用户觉得) 它同时能够做多件事情，事实上，它是快速地轮换执行这些任务的。Linux 内核通过使用进程，来 管理多任务。通过进程，Linux 安排不同的程序等待使用 CPU。

有时候，计算机变得呆滞，运行缓慢，或者一个应用程序停止响应。在这一章中，我们将看一些 可用的命令行工具，这些工具帮助我们查看程序的执行状态，以及怎样终止行为不当的进程。

#### 进程是怎样工作的

当系统启动的时候，内核先把一些它自己的程序初始化为进程，然后运行一个叫做 init 的程序。init 依次地再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。

一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个父进程创建了一个子进程。

内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存进行跟踪。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。

## 查看进程

#### ps - 当前进程快照

Ps 命令可以报告当前进程快照，ps 程序有许多选项，它最简单地使用形式是这样的，我们一般用 `ps` 来寻找进程。

```bash
[me@linuxbox ~]$ ps
PID TTY           TIME CMD
5198  pts/1    00:00:00 bash
10129 pts/1   00:00:00 ps
```

上例中，列出了两个进程，进程 5198 和进程 10129，各自代表命令 bash 和 ps。正如我们所看到的， 默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。

我们先看一下 ps 命令运行结果的其它字段。 TTY 是 “Teletype” 的简写，是指进程的控制终端。TIME 字段表示 进程所消耗的 CPU 时间数量。

**选项**

如果给 ps 命令加上 `x` 选项，我们可以得到更多关于系统运行状态的信息：

```bash
[me@linuxbox ~]$ ps x
PID TTY   STAT   TIME COMMAND
2799 ?    Ssl    0:00 /usr/libexec/bonobo-activation-server –ac
2820 ?    Sl     0:01 /usr/libexec/evolution-data-server-1.10 --
...
```

加上 “x” 选项（注意没有开头的 “-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么 终端（如果有的话）控制。在 TTY 一栏中出现的 “?” ，表示没有控制终端。使用这个 “x” 选项，可以看到我们所拥有的每个进程的信息。同时，输出结果中，新添加了一栏，标题为 STAT 。STAT 是 “state” 的简写，它揭示了进程当前状态：

| 状态 | 意义                                                         |
| :--- | :----------------------------------------------------------- |
| R    | 运行。这意味着，进程正在运行或准备运行。                     |
| S    | 正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。 |
| D    | 不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。 |
| T    | 已停止. 已经指示进程停止运行。稍后介绍更多。                 |
| Z    | 一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除） |
| <    | 一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。 |
| N    | 低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。 |

另一个流行的选项组合是 “aux”（不带开头的”-“字符）。这会给我们更多信息：

```bash
[me@linuxbox ~]$ ps aux
USER   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     1   0.0   0.0    2136    644  ?     Ss     Mar05   0:31  init
root     2   0.0   0.0       0      0  ?     S&lt;     Mar05   0:00  [kt]

and many more...
```

通过这些选项，我们得到 这些额外的列：

| 标题  | 意思                                           |
| :---- | :--------------------------------------------- |
| USER  | 用户 ID. 进程的所有者。                        |
| %CPU  | 以百分比表示的 CPU 使用率                      |
| %MEM  | 以百分比表示的内存使用率                       |
| VSZ   | 虚拟内存大小                                   |
| RSS   | 进程占用的物理内存的大小，以千字节为单位。     |
| START | 进程运行的起始时间。若超过24小时，则用天表示。 |

#### top - 动态查看进程

虽然 ps 命令能展示许多计算机运行状态的信息，但是它只是提供执行时刻机器状态快照。 为看到更多动态的信息，我们使用 top 命令：

```bash
[me@linuxbox ~]$ top
```

top 程序连续显示系统进程更新的信息（默认情况下，每三分钟更新一次），”top”这个名字 来源于这个事实，top 程序是用来查看系统中“顶端”进程的。top 显示结果由两部分组成： 最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。

```bash
top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
Tasks: 109 total,   1 running,  106 sleeping,    0 stopped,    2 zombie
Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
Mem:   319496k total,   314860k used,   4636k free,   19392k buff
Swap:  875500k total,   149128k used,   726372k free,  114676k cach

 PID  USER       PR   NI   VIRT   RES   SHR  S %CPU  %MEM   TIME+    COMMAND
6244  me         39   19  31752  3124  2188  S  6.3   1.0   16:24.42 trackerd
....
```

其中系统概要包含许多有用信息。**下表是对系统概要的说明：**

| 行号 | 字段          | 意义                                                         |
| :--- | :------------ | :----------------------------------------------------------- |
| 1    | top           | 程序名。                                                     |
|      | 14:59:20      | 当前时间。                                                   |
|      | up 6:30       | 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。 |
|      | 2 users       | 有两个用户登录系统。                                         |
|      | load average: | 加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数， 这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。 |
| 2    | Tasks:        | 总结了进程数目和各种进程状态。                               |
| 3    | Cpu(s):       | 这一行描述了 CPU 正在执行的进程的特性。                      |
|      | 0.7%us        | 0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。 |
|      | 1.0%sy        | 1.0%的 CPU 时间被用于系统（内核）进程。                      |
|      | 0.0%ni        | 0.0%的 CPU 时间被用于"nice"（低优先级）进程。                |
|      | 98.3%id       | 98.3%的 CPU 时间是空闲的。                                   |
|      | 0.0%wa        | 0.0%的 CPU 时间来等待 I/O。                                  |
| 4    | Mem:          | 展示物理内存的使用情况。                                     |
| 5    | Swap:         | 展示交换分区（虚拟内存）的使用情况。                         |

**下表是对进程列表字段的说明：**

| 字段    | 含义                                                         |
| :------ | :----------------------------------------------------------- |
| PID     | 进程id；                                                     |
| USER    | 该进程对应的用户；                                           |
| PR      | 优先级；                                                     |
| VIRT    | 虚拟内存；                                                   |
| RES     | 常驻内存；                                                   |
| SHR     | 共享内存；计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR） |
| S       | 表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）； |
| %MEM    | 表示内存的占用百分比；                                       |
| TIME+   | 执行的时间；                                                 |
| COMMAND | 进程的名称或者路径                                           |

**在运行top的时候，可以按下方便的快捷键：**

h：显示程序的帮助屏幕；

q：退出 top 程序；

M：表示将结果按照内存（MEM）从高到低进行降序排列；

P：表示将结果按照CPU使用率从高到低进行降序排列；

1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息；

## 后台运行

#### &

当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上& 实现后台运行。例如：`sh test.sh &`

在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：

```bash
$ command  >  out.file  2>&1  & 
```

这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。

> **PS：**成功地提交进程后，会显示出一个进程号，可以用来监控该进程，或杀死它。
>
> `ps -ef | grep 进程号 或者 kill -9 进程号`

#### nohup

使用&命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思(no hang up)。该命令的一般形式为：

```bash
$ nohup command &
```

如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中(一般是在你启动程序的文件夹)，除非另外指定了输出文件：

```bash
$ nohup command > myout.file 2>&1 &
$ nohup command &> myout.file &			# 新版
```

使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户**非正常退出或者结束的时候**，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。

**2>&1解析**

```bash
$ command >out.file 2>&1 &
```

- command>out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。
- 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&， 是让该命令在后台执行。
- 试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.

#### job

- **jobs**: 查看当前有多少在后台运行的命令。
  - jobs -l 选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。
  - 如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。

>- **ctrl + z**：可以将一个正在前台执行的命令放到后台，并且处于暂停状态。
>- **ctrl + c**：终止前台命令。

#### fg

一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。使用 fg 命令，让一个进程返回前台执行：

```bash
[me@linuxbox ~]$ jobs
[1]+ Running        xlogo &
[me@linuxbox ~]$ fg %1
xlogo
```

fg 命令之后，跟随着一个百分号和工作序号（叫做 jobspec）。如果我们只有一个后台任务，那么 jobspec 是可有可无的。输入 Ctrl-c 来终止 xlogo 程序。

## 终止进程

kill 命令被用来“杀死”程序，其实 kill 命令不是确切地“杀死”程序，而是给程序发送信号。信号是操作系统与程序之间进行通信，所采用的几种方式中的一种。我们已经看到 信号，在使用 Ctrl-c 和 Ctrl-z 的过程中。当终端接受了其中一个按键组合后，它会给在前端运行 的程序发送一个信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT（中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（终端停止）的信号。程序，反过来，倾听信号的到来，当程序 接到信号之后，则做出响应。一个程序能够倾听和响应信号，这个事实允许一个程序做些事情， 比如，当程序接到一个终止信号时，它可以保存所做的工作。

#### 通过 kill 命令给进程发送信号

kill 命令被用来给程序发送信号。它最常见的语法形式看起来像这样：

```bash
kill [-signal] PID...
```

| 编号 | 名字 | 含义 |
| ---- | ---- | ---- |
| 1 | HUP | 发送这个信号到终端机上的前台程序，程序会终止。 |
| 2    | INT  | 许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。 \|中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。 |
| 9    | KILL | 杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。 因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。 |
| 15   | TERM | 终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。 |
| 18   | CONT | 继续。在停止一段时间后，进程恢复运行。 |
| 19   | STOP | 停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被发送到目标进程，因此它不能被忽略。 |


```bash
[me@linuxbox ~]$ xlogo &
[1] 13546
[me@linuxbox ~]$ kill -1 13546
[1]+ Hangup         xlogo
```

> **注意：**进程，和文件一样，拥有所有者，所以为了能够通过 kill 命令来给进程发送信号， 你必须是进程的所有者（或超级用户）。

除了上表列出的 kill 命令最常使用的信号之外，还有一些系统频繁使用的信号。以下是其它一些常用 信号列表：

| 编号 | 名字 | 含义 |
| ---- | ---- | ---- |
| 3    | QUIT | 退出 |
| 11   | SEGV | 段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。 |
| 20   | TSTP | 终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。 |
| 28   | WINCH | 改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。 |


通过下面的命令可以得到一个完整的信号列表：

```bash
[me@linuxbox ~]$ kill -l
```

#### 通过 killall 命令给多个进程发送信号

也有可能通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号。下面是 killall 命令的语法形式：

```bash
killall [-u user] [-signal] name...
```

记住，和 kill 命令一样，你必须拥有超级用户权限才能给不属于你的进程发送信号。

```bash
[me@linuxbox ~]$ xlogo &
[1] 18801
[me@linuxbox ~]$ xlogo &
[2] 18802
[me@linuxbox ~]$ killall xlogo
[1]- Terminated                xlogo
[2]+ Terminated                xlogo
```

## 进程清理

------

我们知道在 `Unix/Linux` 中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。

子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束，当一个进程完成它的工作终止之后，它的父进程需要调用 `wait()` 或者 `waitpid()` 系统调用取得子进程的终止状态。

#### 僵尸进程

`Unix` 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。

这种机制就是：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息(`the process ID`,`the termination status of the process`，
`the amount of CPU time taken by the process` 等)。直到父进程通过 `wait/waitpid` 来取时才释放。 

但这样就导致了问题，如果进程不调用 wait/waitpid 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。此即为僵尸进程的危害，应当避免。

如果子进程在 `exit()` 之后，父进程没有来得及处理，这时用 `ps` 命令就能看到子进程的状态是 `Z`。

#### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程，孤儿进程将被 `init` 进程 (进程号为 `1`) 所收养，并由 `init` 进程对它们完成状态收集工作。

每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 `init`，而 `init` 进程会循环地 `wait()` 它的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，`init` 进程就会代表党和政府出面处理它的一切善后工作，因此孤儿进程并不会有什么危害。

#### 清理进程

首先我们可以通过 `top` 命令查看一下是否有僵尸进程：

```bash
Tasks:  72 total,   1 running,  71 sleeping,   0 stopped,   0 zombie
```

或者通过 `ps` 命令：

```bash
ps -ef | grep defunct
```

严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过 `kill` 发送 `SIGTERM` 或者 `SIGKILL` 信号啦）。

枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 `init` 进程接管，`init` 进程会 `wait()` 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能瞑目而去了。

## 更多命令

--------

因为监测进程是一个很重要的系统管理任务，所以有许多命令与它相关。玩玩下面几个命令：
| 命令名 | 命令描述 |
| ------ | -------- |
| pstree | 输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。 |
| vmstat | 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。 终止输出，按下 Ctrl-c 组合键。 |
| xload | 一个图形界面程序，可以画出系统负载的图形。 |
| tload | 与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。 |


