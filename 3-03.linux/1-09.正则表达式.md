## 正则表达式

------

正则表达式是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹配 文件和路径名的 `shell` 通配符比较相似，但其规模更庞大。许多命令行工具和大多数的编程语言 都支持正则表达式，以此来帮助解决文本操作问题。然而并不是所有的正则表达式都是一样的，不同工具以及不同语言之间的正则表达式都略有差异。我们将会限定 `POSIX` 标准中描述的正则表达式。

## grep

----

`grep` 程序，它会用到正则表达式。实际上，`grep` 这个名字来自于短语 `global regular expression print`，所以我们能看出 `grep` 程序和正则表达式有关联。 本质上，`grep` 程序会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。

`grep` 程序以这样的方式来接受选项和参数：

```shell
grep [options] regex [file...]
```

`regex` 指的是正则，`file` 指的是文件路径，同时提供了丰富的参数：

| 选项 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| -i   | 忽略大小写。不会区分大小写字符。也可用--ignore-case 来指定。 |
| -v   | 不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序 只会不包含匹配项的文本行。也可用--invert-match 来指定。 |
| -c   | 打印匹配的数量（或者是不匹配的数目，若指定了-v 选项），而不是文本行本身。 也可用--count 选项来指定。 |
| -l   | 打印包含匹配项的文件名，而不是文本行本身，也可用--files-with-matches 选项来指定。 |
| -L   | 相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用--files-without-match 来指定。 |
| -n   | 在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number 选项来指定。 |
| -h   | 应用于多文件搜索，不输出文件名。也可用--no-filename 选项来指定。 |
| -E   | open ERE regexp |

为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：

```shell
> ls /bin > dirlist-bin.txt
> ls /usr/bin > dirlist-usr-bin.txt
> ls /sbin > dirlist-sbin.txt
> ls /usr/sbin > dirlist-usr-sbin.txt
> ls dirlist*.txt
# dirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txt
# dirlist-usr-bin.txt
```

我们能够对我们的文件列表执行简单的搜索，像这样：

```shell
> grep bzip dirlist*.txt
dirlist-bin.txt:bzip2
dirlist-bin.txt:bzip2recover
```

在这个例子里，grep 程序在所有列出的文件中搜索字符串 bzip，然后找到两个匹配项，其都在 文件 dirlist-bin.txt 中。如果我们只是对包含匹配项的文件列表，而不是对匹配项本身感兴趣 的话，我们可以指定-l 选项：

```shell
> grep -l bzip dirlist*.txt
dirlist-bin.txt
```

相反地，如果我们只想查看不包含匹配项的文件列表，我们可以这样操作：

```shell
> grep -L bzip dirlist*.txt
dirlist-sbin.txt
dirlist-usr-bin.txt
dirlist-usr-sbin.txt
```

## 元字符

-------

字符串 `bzip` 中的所有字符都是原义字符，因为它们匹配本身。除了原义字符之外，正则表达式也可能包含元字符，其被用来指定更复杂的匹配项。 正则表达式元字符由以下字符组成：

```shell
^ $ . [ ] { } - ? * + ( ) | \
```

然后其它所有字符都被认为是原义字符，虽然在个别情况下，反斜杠会被用来创建元序列， 也允许元字符被转义为原义字符，而不是被解释为元字符。

> **注意** 正如我们所见到的，当 `shell` 执行展开的时候，许多正则表达式元字符，也是对 `shell` 有特殊 含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号引起来至关重要， 这样可以阻止 `shell` 试图展开它们。

#### BRE and ERE

`POSIX` 把正则表达式的实现分成了两类： 基本正则表达式 `BRE` 和扩展的正则表达式 `ERE`。

`BRE` 和 `ERE` 之间有什么区别呢？这是关于元字符的问题。BRE 可以辨别以下元字符：

```
^ $ . [ ] *
```

其它的所有字符被认为是文本字符。ERE 添加了以下元字符（以及与其相关的功能）:

```
( ) { } ? + |
```

## BRE

-------

`Basic regexp` 由 `POSIX` 定义，标准的正则表达式规则。

**POISX**

`POSIX` 是 `IEEE` 定义的操作系统规范，其将会定义 `Unix` 系统以及类 `Unix` 的系统如何执行。这些标准，正式成为 `IEEE 1003`， 定义了应用程序编程接口 `APIs`，`shell` 和一些实用程序，其将会在标准的类 `Unix` 操作系统中找到。`POSIX` 这个名字，象征着可移植的操作系统接口。

#### 任何字符: `.`

第一个元字符是圆点字符，其被用来匹配任意字符。如果我们在正则表达式中包含它， 它将会匹配在此位置的任意一个字符：

```shell
> grep -h '.zip' dirlist*.txt
# bunzip2
# bzip2
# bzip2recover
# gunzip
# gzip
# funzip
# gpg-zip
# preunzip
# prezip
# prezip-bin
# unzip
# unzipsfx
```

注意没有找到这个 `zip` 程序。这是因为在我们的正则表达式中包含的圆点字符把所要求的匹配项的长度增加到四个字符，并且字符串 `zip` 只包含三个字符，所以这个 `zip` 程序不匹配。

另外，如果我们的文件列表中有一些文件的扩展名是 `.zip`，则它们也会成为匹配项，因为文件扩展名中的圆点符号也会被看作是 “任意字符”。

#### 锚点: `^ $`

插入符号和美元符号被看作是锚点。这意味着正则表达式 只有在文本行的开头 `^` 或末尾 `$` 被找到时，才算发生一次匹配。

```shell
> grep -h '^zip' dirlist*.txt
# zip
# zipcloak
# zipgrep
# zipinfo
# zipnote
# zipsplit
> grep -h 'zip$' dirlist*.txt
# gunzip
# gzip
# funzip
# gpg-zip
# preunzip
# prezip
# unzip
# zip
```

`^zip$` 即限定了行首又限定了行尾，同时包含字符串 `zip`（例如，zip 独占一行）的匹配行。 

```shell
> grep -h '^zip$' dirlist*.txt
zip
```

注意正则表达式 `^$`（行首和行尾之间没有字符）会匹配空行。

```shell
grep -n "^$" *
# bin.txt:2:
# bin.txt:3:
# bin.txt:39:
```

#### `[]` 表达式

通过使用中括号表达式，我们也能够从一个指定的字符集合（包含在不加中括号的情况下会被解释为元字符的字符）中匹配一个单个的字符。

```shell
grep -h '[bg]zip' dirlist*.txt
bzip2
bzip2recover
gzip
```

**否定 `^`**

如果一个中括号表达式中的第一个字符是一个插入字符，这个插入字符 `^` 会激活否定功能，则剩余的字符被看作是不会在给定的字符位置出现的字符集合。

```shell
grep -h '[^bg]zip' dirlist*.txt
# bunzip2
# gunzip
# funzip
# gpg-zip
# preunzip
# prezip
# prezip-bin
# unzip
# unzipsfx
```

**连字符**

如果我们想要构建一个正则表达式，它可以在我们的列表中找到每个以大写字母开头的文件，我们可以这样做：

```shell
> grep -h '^[ABCDEFGHIJKLMNOPQRSTUVWXZY]' dirlist*.txt
```

这只是一个在正则表达式中输入 `26` 个大写字母的问题。但是输入所有字母非常令人烦恼，所以有另外一种方式，用连字符表达一个区间：

```shell
> grep -h '^[A-Z]' dirlist*.txt
```

通过使用一个三字符区域，我们能够缩写 `26` 个字母。任意字符的区域都能按照这种方式表达，包括多个区域，比如下面这个表达式就匹配了所有以字母和数字开头的文件名：

```shell
> grep -h '^[A-Za-z0-9]' dirlist*.txt
```

如果想让连字符恢复它原有的功能，只需要将它放在最前面：

```shell
> grep -h '[-AZ]' dirlist*.txt
```

## ERE

-------

`extand regexp` 拓展的正则表达式，开启这个支持需要在 `grep` 中添加 `-E` 选项：

```shell
grep -E '|(){}'
```

#### 交替 `|`

扩展表达式的第一个特性叫做 `alternation` (交替)，其是一款允许从**一系列表达式**之间选择匹配项的实用程序。首先，让我们试一个普通的字符串匹配：

```shell
> echo "AAA" | grep -E 'AAA|BBB'
# AAA
> echo "BBB" | grep -E 'AAA|BBB'
# BBB
```

#### 分组 `()`  

使用 `()` 表达式对匹配规则进行分组，比如上面的交替表达式，为了把 `alternation` 和其它正则表达式元素结合起来，我们可以使用 `()` 来分离 `alternation`。

```shell
> grep -Eh '^bz|gz|zip' dirlist*.txt
# bzip, *gz, gz*, *gz*, same as zip
> grep -Eh '^(bz|gz|zip)' dirlist*.txt
# bz*, gz*, zip*
```

这个表达式会在列表中匹配以 `bz`, `gz`，`zip`开头的文件名。如果我们删除了圆括号，这个表达式的意思会变成匹配任意以 `bz` 开头，或包含 `gz`，或包含 `zip` 的文件名。

#### 限定符

扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。

**`?` - 匹配零个或一个元素**

`?` 限定符表达其前面的元素可有可无。

比方说我们想要查看一个电话号码的真实性， 其中 `()` 元素可有可无：

```shell
(nnn) nnn-nnnn
 nnn  nnn-nnnn
```

这里的 `n` 是一个数字。我们可以构建一个像这样的正则表达式：

```go
^\(?[0-9][0-9][0-9]\)?  [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
```

在这个表达式中，我们在圆括号之后加上一个问号，来表示它们将被匹配零次或一次。再一次，因为 通常圆括号都是元字符（在 `ERE` 中），所以我们在圆括号之前加上了反斜杠，使它们成为文本字符。

**`*` - 匹配零个或多个元素**

像 `?` 元字符一样，这个 `*` 被用来表示一个可选的字符；然而，又与 `?` 不同，匹配的字符可以出现任意多次。

比如说我们想匹配任意多个小写字母：

```shell
'[a-z]*'
```

**`+` - 匹配一个或多个元素**

这个 `+` 元字符的作用与 `*` 非常相似，除了它要求前面的元素至少出现一次匹配。

这个正则表达式只匹配那些由一个或多个字母字符组构成的文本行，字母字符之间由单个空格分开：

```shell
^([[:alpha:]]+ ?)+$
> echo "This that" | grep -E '^([[:alpha:]]+ ?)+$'
This that
```

**`{}` - 匹配特定个数的元素**

这个 `{` 和 `}` 元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：

| 限定符 | 意思                                                     |
| :----- | :------------------------------------------------------- |
| {n}    | 匹配前面的元素，如果它确切地出现了 n 次。                |
| {n,m}  | 匹配前面的元素，如果它至少出现了 n 次，但是不多于 m 次。 |
| {n,}   | 匹配前面的元素，如果它出现了 n 次或多于 n 次。           |
| {,m}   | 匹配前面的元素，如果它出现的次数不多于 m 次。            |

回到之前处理电话号码的例子，我们能够使用这种指定重复次数的方法来简化我们最初的正则表达式：

```go
^\(?[0-9][0-9][0-9]\)?  [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
```

简化为：

```go
^\(?[0-9]{3}\)?  [0-9]{3}-[0-9]{4}$
```

