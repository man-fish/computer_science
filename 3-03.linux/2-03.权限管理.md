## 权限概述

-------

在多用户（可以不同时）计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用或存储量的限制。

在Linux中分别有读、写、执行权限：

**读权限：**

- 对于文件夹来说，读权限影响用户是否能够列出目录结构

- 对于文件来说，读权限影响用户是否可以查看文件内容 

**写权限：**

- 对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档

- 对于文件来说，写权限影响用户是否可以编辑文件内容

**执行权限：**

- 一般都是对于文件来说，特别脚本文件。

> **总述：** Linux系统一般将文件可存/取访问的身份分为3个类别：owner、group、others，且3种身份各有read、write、execute等权限。

## 身份概述

-----

### Owner身份

文件所有者，默认为文档的创建者。

由于Linux是多用户、多任务的操作系统，因此可能常常有多人同时在某台主机上工作，但每个人均可在主机上设置文件的权限，让其成为个人的“私密文件”，即个人所有者。因为设置了适当的文件权限，除本人（文件所有者）之外的用户无法查看文件内容。

### Group身份

与文件所有者同组的用户

与文件所有者同组最有用的功能就体现在多个团队在同一台主机上开发资源的时候。例如主机上有A、C两个团体，A团体要完成一份报告F。由于设置了适当的权限，A团体中的成员都能互相修改对方的数据，但是团体C的成员则不能修改F的内容，甚至连查看的权限都没有。同时，团体的成员也能设置自己的私密文件，让团队的其它成员也读取不了文件数据。在Linux中，每个账户支持多个用户组。如用户a1、b1即可属于A用户组，也能属于B用户组「主组和附加组」。

### Others身份

其他人，相对于所有者

既不是同组用户也不是所有者。

### Root用户

超级用户 OAA - one above all

## 权限介绍

要设置权限，就需要知道文件的一些基本属性和权限的分配规则。在Linux中，ls命令常用来查看文件的属性，用于显示文件的文件名和相关属性。

```bash
➜ ls -l
total 3896
drwx------@  3 inno  staff       96  1 26 17:37 Applications
drwx------+  8 inno  staff      256  2  9 08:05 Movies
drwxr-xr-x   3 inno  staff       96  1 22 00:47 Postman
drwxr-xr-x+  4 inno  staff      128  1 21 21:11 Public
drwxr-xr-x  12 inno  staff      384  1 31 07:37 blog➜ ls -l
```

列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能经常看到 的文件类型（还有其它的，不常见类型）：

表10-1: 文件类型

| 属性 | 文件类型                                                     |
| :--- | :----------------------------------------------------------- |
| -    | 一个普通文件                                                 |
| d    | 一个目录                                                     |
| l    | 一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 |
| c    | 一个字符设备文件。这种文件类型是指按照字节流，来处理数据的设备。 比如说终端机，或者调制解调器 |
| b    | 一个块设备文件。这种文件类型是指按照数据块，来处理数据的设备，例如一个硬盘，或者 CD-ROM 盘。 |

剩下的九个字符，叫做文件模式，代表着文件所有者，文件组所有者，和其他人的读，写，执行权限。

> **`drwxr-xr-x`**
>
> d：文件类型，rwx：所有者权限，r-x：同组权限，r-x：访客权限。
>
> - 其中“-”表示改行对应的文档类型为文件，“d”表示文档类型为文件夹，“l”表示软连接，”s“表示套接字
> - 在Linux中隐藏文档一般都是以“.”开头。

## 权限设置

------

#### chmod

更改文件或目录的模式（权限），可以利用 chmod 命令。注意只有文件的所有者或者超级用户才 能更改文件或目录的模式。

- 语法：`#chmod` 选项 权限模式 文档
- 常用选项：
  - -R：递归设置权限（当文档类型为文件夹的时候）
  - 权限模式：就是该文档需要设置的权限信息
  - 文档：可以是文件，也可以是文件夹，可以是相对路径也可以是绝对路径。

```bash
~
➜ chmod 777 see

~
➜ ll | grep see
-rwxrwxrwx   1 inno  staff     0B  2 21 18:20 see
```

#### 权限模式

chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法，或 符号表示法。

**八进制表示法：**

对于八进制表示法，我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。下表展示了 我们所要表达的意思：

| Octal | Binary | File Mode |
| :---- | :----- | :-------- |
| 0     | 000    | ---       |
| 1     | 001    | --x       |
| 2     | 010    | -w-       |
| 3     | 011    | -wx       |
| 4     | 100    | r--       |
| 5     | 101    | r-x       |
| 6     | 110    | rw-       |
| 7     | 111    | rwx       |

通过使用3个八进制数字，我们能够设置文件所有者，用户组，和其他人的权限：

#### 注意点

这样的权限不能出现：

```bash
能写：2   -> 能写不能读
能写能执行：1 + 2 = 3 	->  能写不能读
```

使用root用户创建一个文件夹（/oo），给777权限，切换到test用户（不是文档所有者，也不是同组用户，属于other部分）。

- 问题1：test用户是否可以打开oo/xx.txt文件？【能打开】

- 问题2：test用户是否可以编辑oo/xx.txt文件？【可以】

- 问题3：test用户是否可以删除oo/xx.txt文件？【不可以，同样还不允许创建文件/文件夹、移动文件、重命名文件】

> 在Linux中，如果要删除一个文件，不是看文件有没有对应的权限，**而是看文件所在的目录是否有写权限**，如果有才可以删除。

#### umask － 设置默认权限

当创建一个文件时，umask 命令控制着文件的默认权限。umask 命令使用八进制表示法来表达 从文件模式属性中删除一个位掩码。大家看下面的例子：

```bash
[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ umask
0002
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me   me   0 2008-03-06 14:53 foo.txt
```

首先，删除文件 foo.txt，以此确定我们从新开始。下一步，运行不带参数的 umask 命令， 看一下当前的掩码值。响应的数值是0002（0022是另一个常用值），这个数值是掩码的八进制 表示形式。下一步，我们创建文件 foo.txt，并且保留它的权限。

我们可以看到文件所有者和用户组都得到读权限和写权限，而其他人只是得到读权限。 其他人没有得到写权限的原因是由掩码值决定的。重复我们的实验，这次自己设置掩码值：

```
[me@linuxbox ~]$ rm foo.txt
[me@linuxbox ~]$ umask 0000
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-rw- 1 me   me    0 2008-03-06 14:58 foo.txt
```

当掩码设置为0000（实质上是关掉它）之后，我们看到其他人能够读写文件。为了弄明白这是 怎么回事，我们需要看一下掩码的八进制形式。把掩码展开成二进制形式，然后与文件属性 相比较，看看有什么区别：

|                    |                 |
| :----------------- | :-------------- |
| Original file mode | --- rw- rw- rw- |
| Mask               | 000 000 000 010 |
| Result             | --- rw- rw- r-- |

此刻先忽略掉开头的三个零（我们一会儿再讨论），注意掩码中若出现一个数字1，则 删除文件模式中和这个1在相同位置的属性，在这是指其他人的写权限。这就是掩码要完成的 任务。掩码的二进制形式中，出现数字1的位置，相应地关掉一个文件模式属性。看一下 掩码0022的作用：

|                    |                 |
| :----------------- | :-------------- |
| Original file mode | --- rw- rw- rw- |
| Mask               | 000 000 010 010 |
| Result             | --- rw- r-- r-- |

又一次，二进制中数字1出现的位置，相对应的属性被删除。再试一下其它的掩码值（一些带数字7的） ，习惯于掩码的工作原理。当你实验完成之后，要记得清理现场：

```
[me@linuxbox ~]$ rm foo.txt; umask 0002
```

大多数情况下，你不必修改掩码值，系统提供的默认掩码值就很好了。然而，在一些高 安全级别下，你要能控制掩码值。

> **一些特殊权限：前三位**
>
> 虽然我们通常看到一个八进制的权限掩码用三位数字来表示，但是从技术层面上来讲， 用四位数字来表示它更确切些。为什么呢？因为，除了读取，写入，和执行权限之外，还有 其它的，较少用到的权限设置。
>
> 其中之一是 setuid 位（八进制4000)。当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。很明显，因为这会引起安全方面的问题，所有可以 设置 setuid 位的程序个数，必须控制在绝对小的范围内。
>
> 第二个是 setgid 位（八进制2000），这个相似于 setuid 位，把有效用户组 ID 从真正的 用户组 ID 更改为文件所有者的组 ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。
>
> 第三个是 sticky 位（八进制1000）。这个继承于 Unix，在 Unix 中，它可能把一个可执行文件 标志为“不可交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。这个经常用来控制访问共享目录，比方说/tmp。

## 属主与属组设置

------

属主：所属的用户（文件的主人）

属组：所属的用户组

```bash
~
➜ ll
total 3896
drwx------@  3 inno  staff    96B  1 26 17:37 Applications
						 # 拥有者 所属组
```

这两项信息在文档创建的时候会使用创建者的信息（用户名、用户所属的主组名称）。

如果有时候去删除某个用户，则该用户对应的文档的属主和属组信息就需要去修改。

#### chown（重点）

chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。chown 命令 的语法看起来像这样：

```
chown [owner][:[group]] file...
```

- 作用：更改文档的所属用户

- 语法：`#chown  -R  username filename` 文档路径
- 参数：-R 递归

```bash
~
➜ su root
sh-3.2# chown root see

~
➜ ll | grep see
-rwxrwxrwx@  1 root  staff     0B  2 21 18:20 see
```

- 作用2:既更改所属的用户，也修改所属的用户组
- 语法：#chown  -R  username:groupname   文档路径

```bash
sh-3.2# chown inno:staff see
sh-3.2# ls -l | grep see
-rwxrwxrwx@  1 inno  staff        0  2 21 18:20 see
```

#### chgrp（了解）

- 作用：更改文档的所属用户组
- 语法：#chgrp  -R  groupname  文档的路径
- 参数：-R 递归

```bash
sh-3.2# chgrp wheel see
sh-3.2# ls -l | grep see
-rwxrwxrwx@  1 root  wheel        0  2 21 18:20 see
```

## 权限拓展命令

-------

问题：reboot、shutdown、init、halt、部分权限管理，在普通用户身份上都是操作不了，但是有些特殊的情况下又需要有执行权限。又不可能让root用户把自己的密码告诉普通用户，这个问题该怎么解决？

#### sudo命令

使用`sudo（switch user do）`命令来进行权限设置。sudo 命令在很多方面都相似于 su 命令，但是 `Sudo`可以让`管理员（root）`事先定义某些特殊命令谁可以执行， 另一个重要差异是` sudo `命令不要求超级用户的密码。使用命令时，用户使用他/她自己的密码 来认证。

- 格式：`sudo command options`

默认sudo中是没有除root之外用户的规则，要想使用则先配置sudo。想知道 sudo 可以授予哪些权限，使用”-l”选项，列出所有权限：

```
[me@linuxbox ~]$ sudo -l
User me may run the following commands on this host:
(ALL) ALL
```

**sudo配置文件：**

要配置`sudo`命令集可以在`sudo/etc/sudoers`中进行编辑。

```ini
# root and users in group wheel can run anything on any machine as any user
root		ALL = (ALL) ALL
%admin		ALL = (ALL) ALL
```

1. Root表示用户名，如果是用户组，则可以写成“%组名”

2. ALL：表示允许登录的主机（地址白名单）

3. (ALL)：表示以谁的身份执行，ALL表示root身份

4. ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割

**注意：**

写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。路径可以使用which命令来查看，语法：#which 指令名称。

**演示：**

```bash
[patrick@inno root]$ sudo useradd -c "test sudo" mico

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for patrick:

[patrick@inno root]$ sudo passwd mico
更改用户 mico 的密码 。
新的 密码：
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
```

> 在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码。

**注意:**

禁止修改root密码的配置（先允许全部，再拒绝root密码设置）： `/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root`

```ini
## Allow some users todo
patrick ALL=(ALL)       /usr/sbin/useradd,/usr/bin/passwd [A-Za-z]*,!/usr/bin/passwd root
```

#### su 命令

除了`sudo`之外还有`su (switch user)`命令，su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：

```
su [-[l]] [user]
```

如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。如果不指定用户，那么就假定是 超级用户。注意，选项”-l”可以缩写为”-“。启动超级用户的 shell， 我们可以这样做：

```bash
[me@linuxbox ~]$ su -
Password:
[root@linuxbox ~]#
```

当工作完成后， 输入”exit”，则返回到原来的 shell:

```bash
[root@linuxbox ~]# exit
[me@linuxbox ~]$
```

以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：

```bash
su -c 'command'
```

使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想 命令在我们的 shell 中展开，但需要在新 shell 中展开。

```bash
[me@linuxbox ~]$ su -c 'ls -l /root/*'
Password:
-rw------- 1 root root    754 2007-08-11 03:19 /root/anaconda-ks.cfg

/root/Mail:
total 0
[me@linuxbox ~]$
```

