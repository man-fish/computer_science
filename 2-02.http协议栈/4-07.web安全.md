# SOP、CORS、CSRF、XSS

## SOP — 同源策略

-----

#### 同源

先解释何为同源：协议、域名、端口都一样，就是同源。

| url                                           | 同源 |
| :-------------------------------------------- | :--- |
| [https://niconico.com](https://niconico.com/) | 基准 |
| https://niconico.com/spirit                   | o    |
| https://sub.niconico.com/spirit               | x    |
| http://niconico.com/spirit                    | x    |
| https://niconico.com:8080/spirit              | x    |

#### 限制

你之所以会遇到 **跨域问题**，正是因为 SOP 的各种限制。但是具体来说限制了什么呢？

如果你说 SOP 就是“限制非同源资源的获取”，这不对，最简单的例子是引用图片、css、js 文件等资源的时候就允许跨域。

如果你说 SOP 就是“禁止跨域请求”，这也不对，本质上 SOP 并不是禁止跨域请求，而是在请求后拦截了请求的回应。

其实表面上 SOP 分两种情况：

+ 可以正常引用 iframe、图片等各种资源，**但是**限制对其内容进行操作
+ 直接限制 ajax 请求，准确来说是**限制操作 ajax 响应结果**，**这会引起后面说到的 CSRF**

但是，本质上这两条是一样的：总之，对于非同源的资源，浏览器可以“直接使用”，但是程序员和用户不可以对这些数据进行操作，杜绝某些居心不良的行为。这就是现代安全浏览器对用户的保护之一。

下面是 3 个在实际应用中会遇到的例子：

+ 使用 ajax 请求其他跨域 API，最常见的情况，前端新手噩梦
+ iframe 与父页面交流（如 DOM 或变量的获取），出现率比较低，而且解决方法也好懂
+ 对跨域图片（例如来源于 `<img>` ）进行操作，在 canvas 操作图片的时候会遇到这个问题

#### 绕过跨域

SOP 虽然让用户更安全，同时也会对程序员带来一定程度的麻烦，因为有时候业务上就是有跨域的需求。绕过跨域的方案由于篇幅所限，并且网上也很多相关文章，所以不在这里展开解决跨域的方案，只给出几个关键词：

如果没有了 SOP：

+ iframe 里的机密信息被肆意读取
+ 更加肆意地进行 CSRF
+ 接口被第三方滥用

对于 ajax

+ 使用 JSONP
+ 后端进行 CORS 配置
+ 后端反向代理
+ 使用 WebSocket

对于 iframe

+ 使用 location.hash 或 window.name 进行信息交流
+ 使用 postMessage

## CSRF — 跨站请求伪造

------

#### 简述

CSRF（Cross-site request forgery）跨站请求伪造，是一种常见的攻击方式。是指 A 网站正常登陆后，cookie 正常保存登录信息，其他网站 B 通过某种方式调用 A 网站接口进行操作，A 的接口会在请求时会自动带上 cookie。

上面说了，SOP 可以通过 html 标签加载资源，而且 SOP 不阻止接口请求而是拦截请求结果，CSRF 恰恰占了这两个便宜。

对于 GET 请求，直接放到 `<img>` 就能神不知鬼不觉地请求跨域接口。

对于 POST 请求，很多例子都使用 form 提交：

```html
<form action="<nowiki>http://bank.com/transfer.do</nowiki>" method="POST">
  <input type="hidden" name="acct" value="MARIA" />
  <input type="hidden" name="amount" value="100000" />
  <input type="submit" value="View my pictures" />
</form>
```

**所以 SOP 不能作为防范 CSRF 的方法**。

回顾 SOP 的限制，这两个例子都是直接用 html 标签发起请求，而浏览器允许这么做，归根到底就是因为**你无法用 js 直接操作获得的结果。**

#### CSRF 对策

SOP 被 CSRF 占了便宜，那真的是一无是处吗？

不是！是否记得 SOP 限制了 cookie 的命名区域，虽然请求会自动带上 cookies，但是攻击者无论如何还是无法**直接获取 cookie 的内容本身**。

所以应对 CSRF 有这样的思路：就是前后端分离常用的鉴权方法，使用 token 鉴权，并且不把 token 存放在 cookie，请求时在请求头上手动加上。

另一个方法是：cookie 里的东西，在发起请求时**通过 query、body 或者 header 带上**。请求到达服务器，那就不核对 cookie 传送的信息，只看自定义字段就好，如果正确，那一定是能看到 cookie 的本域发送的请求，CSRF 则做不到这一点。（这个方法用于前后端分离，后端渲染则可以直接写入到 dom 中）

#### 跨域资源共享 CORS

跨域是浏览器限制，跨域资源共享（Cross-origin resource sharing）也是服务器与浏览器协调的结果。

如果服务器设置了 CORS 相关配置，在返回浏览器的请求头会加上 `Access-Control-Allow-Origin`，浏览器看到这个字段的值与当前的源匹配，就会解锁跨域限制。

## XSS — 跨站脚本攻击

----

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。

这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

+ 来自用户的 UGC 信息
+ 来自第三方的链接
+ URL 参数
+ POST 参数
+ Referer （可能来自不可信的来源）
+ Cookie （可能来自其他子域注入）

### XSS 分类

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种：

+ 存储区：恶意代码存放的位置。
+ 插入点：由谁取得恶意代码，并插入到网页上。

| 类型 | 存储区 | 插入点 |
| ---- | ------ | ------ |
| 存储型 XSS | 后端数据库 | HTML |
|反射型 XSS|URL|HTML| 
|DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript|

#### 存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

#### DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

### 预防存储型和反射型 XSS 攻击

存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

+ 改成纯前端渲染，把代码和数据分隔开。
+ 对 HTML 做充分转义。

#### 纯前端渲染

纯前端渲染的过程：

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

#### 转义 HTML

如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。

常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 `& < > " ' /` 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：

|XSS 安全漏洞|简单转义是否有防护作用| 
|-|-| 
|HTML 标签文字内容|有| 
|HTML 属性值|有| 
|CSS 内联样式|无| 
|内联 JavaScript|无| 
|内联 JSON|无| 
|跳转链接|无|

所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。

## DDoS

-----

拒绝服务（`Denial of Service`，缩写：`DoS`）攻击也称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，服务暂时中断或停止，导致合法用户不能够访问正常网络服务的行为。当攻击者使用网络上多个被攻陷的电脑作为攻击机器向特定的目标发动`DoS`攻击时，称为分布式拒绝服务攻击。

#### **分布式拒绝服务攻击的原理**

分布式拒绝服务攻击DDoS是基于DoS的一种特殊形式的拒绝服务攻击，它是一种分布式、协同的大规模攻击方法。 单个DoS攻击通常使用一对一方法。 它使用了网络协议和操作系统中的某些缺陷，并使用欺骗和伪装策略来进行网络攻击，让网站服务器上充斥着大量需要回复的信息，这消耗了网络带宽或系统资源，导致网络或系统超载和瘫痪，并停止提供正常的网络服务。 与由单个主机发起的DoS攻击相比，分布式拒绝服务攻击DDoS是由数百个甚至数千个随攻击过程入侵并安装的主机同时发起的集体行为。

完整的DDoS攻击体系包括四个部分：攻击者、主控端（主服务器）、代理端和攻击目标。 主控制端和代理端分别用于控制和实际发起攻击。 主控端只发出命令，不参与实际攻击，代理端发出实际的DDoS攻击包。 攻击者可以控制或部分控制主机和代理上的计算机。 在攻击过程中，它将使用各种手段来隐藏自己，使其不被他人发现。 一旦真正的攻击者将攻击命令发送到主机，攻击者就可以关闭或离开网络。 该命令由主服务器发出给每个代理主机。 这样攻击者可以逃避跟踪。 每个攻击代理主机都会向目标主机发送大量服务请求数据包。 这些数据包是伪装的，无法从其来源进行识别。 此外，这些数据包所请求的服务通常会消耗大量系统资源，从而使目标主机为用户提供正常服务，甚至会导致系统崩溃。