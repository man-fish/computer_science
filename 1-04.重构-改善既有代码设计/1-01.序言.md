# 序言

> \[项目地址\]:https://github.com/man-fish/Refactoring，我把书中的实例代码上传到了 `github` 上，通过 `git diff` 可以很清晰看到每一步的重构过程，第一章便在其中。

这一章主要讲讲重构的`why、when、means...`这些基础概念，不会设计重构的具体技巧，前一章的例子应该让你对重构有比较好的感受了。接下来让我们深入探索：

## 何为重构

视上下文不同，「重构」这个词有两种不同的定义：

+ 第一个定义是名词形式：重构（名词）：对软件内部结构的一种调整，目的是在不改变「软件之可察行为」前提下，提高其可堙鮮性，降低苏修改成本。
+ 另一个用法是动词形式：重构（动词）：使用一系列重构准则（手法〕，在不改变「软件之可察行为」前提 下，调整其结构。

定义还需要往两方面扩展。首先，重构的目的是使软件更容易被理解和修改。你可以在软件内部做很多修改，但必须对软件「可受观察之外部行为」只造成很小变化，或甚至不造成变化。与之形成对比的是「性能优化」。和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。

第二点是：重构不会改变软件「可受观察之行为」——重构之后软件功能一如以往。任何用户，不论最终用户或程序员，都不知道已有东西发生了变化。

## 为何重构

重构绝对不是所谓的「银弹」。不过它的确很有价值，虽不是一颗银子弹却是一把「银钳子」，可以帮助你始终良好地控制自己的代码。重构是个工具，它可以（并且应该）为了以下数个目的而被运用。

> 「银弹」`silver bullet`：美国家喻户晓的比喻。美国民间流传月圆之夜狼人出没，只有以纯银子弹射穿狼人心脏，才能制服狼人。

### 改进软件设计

如果没有重构，程序的设计会逐渐腐败变质。当人们只为短期目的，或是在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构，程序员愈来愈难通过阅读源码而理解原本设计。重构很像是在整理代码，你所做的就是让所有东西回到应该的位置上。代码结构的流失是累积性的。愈难看出代码所代表的设计意涵，就愈难保护其中设计，于是该设计就腐败得愈快。经常性的重构可以帮助代码维持自己该有的形态。

同样完成一件事，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事。因此改进设计的一个重要方向就是消除重复代码(`Duplicate Code`)。这个动作的重要性着眼于未来。代码数量减少并不会使系统运行更快，因为这对程序的运行轨迹几乎没有任何明显影响。然而代码数量减少将使未来可能的程序修改动作容易得多。代码愈多，正确的修改就愈困难，因为有更多代码需要理解。

### 使软件更易理解

重构可以帮助我们让代码更易读。一开始进行重构时，你的代码可以正常运行，但结构不够理想。在重构上花一点点时间，就可以让代码更好地表达自己的用途。这种编程模式的核心就是「准确说出你的意思」。

### 发现软件漏洞

对代码的理解，可以帮助我找到臭虫。我承认我不太擅长调试。有些人只要盯着一大段代码就可以找出里面的 `bug`，我可不行。但我发现如果我对代码进行重构，我就可以深入理解代码的作为，并恰到好处地把新的理解反馈回去。搞清楚程序结构的同时，我也清楚了自己所做的一些假设，从这个角度来说，不找到 `bug` 都难矣。

### 提高编程速度

听起来有点违反直觉。当我谈到重构，人们很容易看出它能够提高质量。改善设计、提升可读性、减少错误，这些都是提高质量。但这难道不会降低开发速度吗?

我强烈相信：良好设计是快速软件开发的根本。事实上拥有良好设计才可能达成快速的开发。如果没有良好设计，或许某一段时间内你的进展迅速，但恶劣的设计很快就让你的速度慢下来。你会把时间花在调试上面，无法添加新功能。修改时间愈来愈长，因为你必须花愈来愈多的时间去理解系统、寻找重复代码。随着你给最初程序打上一个又一个的补丁(`patch`)，新特性需要更多代码才能实现。真是个恶性循环。
良好设计是维持软件开发速度的根本。重构可以帮助你更快速地开发软件，因为它阻止系统腐败变质，它甚至还可以提高设计质量。

## 何时重构

几乎任何情况下我都反对专门拨出时问进行重构。在我看来，重构本来就不是一件「特别拨出时间做」的事情，重构应该随时随地进行。你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。

### 三次法则〔The Rule of Three〕

`Don Roberts` 给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是做了；第三次再做类似的事，你就应该重构。

> Tip: 事不过三，三则重构(`Three strikes and you refactor`)。

### 添加功能时一并重构

最常见的重构时机就是我想给软件添加新特性的时候。此时，重构的第一个原因往往是为了帮助我理解需要修改的代码。这些代码可能是别人写的，也可能是我自己写的。无论何时只要我想理解代码所做的事，我就会问自己：是否能对这段代码进行重构，使我能更快理解它。然后我就会重构。

重构是一个快速流畅的过程，一旦完成重构，新特性的添加就会更快速、更流畅。

### 修补错误吋一并重构

调试过程中运用重构，多半是为了让代码更具可读性。当我看着代码并努力理解它的时候，我用重构帮助改善自己的理解。我发现以这种程序来处理代码，常常能够帮助我找出臭虫。你可以这么想：如果收到一份错误报告，这就是需要重构的信号，因为显然代码还不够清晰一不够清晰到让你一目了然发现臭虫。

### 复审代码吋一并重构

重构可以帮助我复审别人的代码。开始重构前我可以先阅读代码，得到一定程度的理解，并提出一些建议。一旦想到一些点子，我就会考虑是否可以通过重构立即轻松地实现它们。如果可以，我就会动手。这样做了几次以后，我可以把代码看得更清楚，提出更多恰当的建议。我不必想像代码「应该是什么样」，我可以「看见」它是什么样。于是我可以获得更髙层次的认识。如果不进行重构，我永远无法得到这样的认识。

极限编程(`Extreme Programming`)[`Beck, XP`]中的「搭档(成对)编程」(`Pair Programming`)形式，把代码复审的积极性发挥到了极致。一旦采用这种形式，所有正式开发任务都由两名开发者在同一台机器上进行。这样便在开发过程中形成随时进行的代码复审工作，而重构也就被包含在幵发过程内了。

## 重构的意义

是什么让程序如此难以相与？下笔此刻，我想起四个原因，它们是：

+ 难以阅读的程序，难以修改。
+ 逻辑复杂(`duplicated logic`)的程序，难以修改。
+ 添加新行为时需要修改既有代码者，难以修改。
+ 带复杂条件逻辑(`complex conditional logic`)的程序，难以修改。

因此，我们希望程序：

+ 容易理解；
+ 所有逻辑都只在唯一地点指定；
+ 新的改动不会危及现有行为；
+ 尽可能简单表达条件逻辑(`conditional logic`)；

重构是这样一个过程：它在一个目前可运行的程序上进行，企图在「不改变程序行为」的情况下赋予上述美好性质，使我们能够继续保持高速开发，从而增加程序的价值。

## 重构的难题

接下来我们来了解一下重构的过程中可能会碰到那些难题：

### 修改接口`Changing Interfaces`

关于对象，另一件重要事情是：它们允许你分开修改软件模块的实现`implementation` 和接口 `interface`。你可以安全地修改某对象内部而不影响他人，但对于接口要特别谨慎——如果接口被修改了，任何事情都有可能发生。

一直对重构带来困扰的一件事就是：许多重构手法的确会修改接口。像 `Rename Method` 这么简单的重构手法所做的一切就是修改接口。这对极为珍贵的封装概念会带来什么影响呢？

如果某个函数的所有调用动作都在你的控制之下，那么即使修改函数名称也不会有任何问题。哪怕面对一个 `public` 函数，只要能取得并修改其所有调用者，你也可以安心地将这个函数易名。只有当需要修改的接口系被那些「找不到，即使找到也不能修改」的代码使用时，接口的修改才会成为问题。如果情况真是如此，我就会说：这个接口是个「已发布接口」(`published interface`)——比公开接口，接口一旦发布，你就再也无法仅仅修改调用者而能够安全地修改接口了。比如说你写了一个代码包发布了出去，之后可能有很多开发者引用了你的依赖包，如果你修改了接口那么所有引用的代码都会宕机。

简言之，如果重构手法改变了已发布接口（`published interface`〕，你必须同时维护新旧两个接口，直到你的所有用户都有时间对这个变化做出反应。幸运的是这不太 困难。你通常都有办法把事情组织好，让旧接口继续工作。请尽量这么做：让旧接口调用新接口。当你要修改某个函数名称时，请留下旧函数，让它调用新函数。千万不要拷贝函数实现码，那会让你陷入「重复代码」（`duplicated code`）的泥淖中难以自拔。

### 难以通过重构手法完成的设计改动

通过重构，可以排除所有设计错误吗？是否存在某些核心设计决策，无法以重构手法修改？在这个领域里，我们的统计数据尚不完整。当然某些情况下我们可以很有效地重构，这常常令我们倍感惊讶，但的确也有难以重构的地方。比如说在一个项目中，我们很难（但还是有可能）将「无安全需求（`no security requirements`）情况下构造起来的系统」重构为「安全性良好的〔`good security`）系统」。

这种情况下我的办法就是「先想像重构的情况」。考虑候选设计方案时，我会问自己：将某个设计重构为另一个设计的难度有多大？如果看上去很简单，我就不必太担心选择是否得当，于是我就会选最简单的设计，哪怕它不能覆盖所有潜在需求也没关系。但如果预先看不到简单的重构办法，我就会在设计上投入更多力气。不过我发现，这种情况很少出现。

### 不要重构

有时候你根本不应该重构——例如当你应该重新编写所有代码的时候。有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。作出这种决定很困难，我承认我也没有什么好准则可以判断何时应该放弃重构。

重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作。你可能只是试着做点测试，然后就发现代码中满是错误，根本无法稳定运作。记住，重构之前，代码必须起码能够在大部分情况下正常运作。
一个折衷办法就是：将「大块头软件」重构为「封装良好的小型组件」。然后你就可以逐一对组件做出「重构或重建」的决定。

如果项目己经非常接近最后期限，你不应该再分心于重构，因为己经没有时间了。不过多个项目经验显示：重构的确能够提高生产力。如果最后你没有足够时间，通常就表示你其实早该进行重构。

## 重构与间接层『`Indirection and Refactoring`』

> 计算机科学是这样一门学科：它相信所有问题都可以通过多一个间接层（`Indirection`）来解决。 `——Dennis DeBruler`

由于软件工程师对间接层如此醉心，你应该不会惊讶大多数重构都为程序引入了更多间接层。重构往往把大型对象拆成数个小型对象，把大型函数拆成数个小型函数。

但是，间接层是一抦双刃剑。每次把一个东西分成两汾，你就需要多管理一个东西。如果某个对象委托（delegate)另一对象，后者又委托另一对象，程序会愈加难以阅读。基于这个观点，你会希望尽量减少间接层。不过间接层也有它的价值。下面就是间接层的某些价值：

1. 允许逻辑共享〔``To enable sharing of logic``）。比如说一个子函数（``submethod``）在两个不同的地点被调用，或``superclass``的某个函数被所有``subclass``共享。 
2. 分开解释「意图」和「实现]``(To explain intention and implementation separately``）。你可以选择每个``class``和函数的名字，这给了你一个解释自己意图的机会。``class``或函数内部则解释实现这个意图的作法。如果``class``和函数内部又以「更小单元的意图」来编写，你所写的代码就可以『与其结构中的大部分重要信息沟通」。
3. 将变化加以隔离（`To isolate change`）。很可能我在两个不同地点使用同一对象，其中一个地点我想改变对象行为，但如果修改了它，我就要冒「同时影响两处」的风险。为此我做出一个`subclass`，并在需要修改处引用这个`subclass`。现在，我可以修改这个`subclass`而不必承担「无意中影响另一处」的风险。
4. 将条件逻辑加以编码（`To encode conditional logic`）。对象有一种匪夷所思的机制：多态函数，可以灵活弹性而清晰地表达条件逻辑。只要显式条件逻辑被转化为函数调用形式，往往便能降低代码的重复、增加清晰度并提髙弹性。

这就是重构游戏：在保持系统现有行为的前提下，如何才能提高系统的质量或降低其成本，从而使它更有价值？

这个游戏中最常见的变量就是：你如何看待你自己的程序。找出一个缺乏「间接层利益」之处，在不修改现有行为的前提下，为它加入一个间接层。现在你获得了一个更有价值的程序，因为它有较髙的质量，让我们在明天（未来）受益。

还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。这种间接层常以中介函数（`intermediate methods`）形式出现，也许曾经有过贡献，但芳华已逝。它也可能是个组件，你本来期望在不同地点共享它，或让它表现出多态性（`polymorphism`），最终却只在一处使用之。如果你找到这种「寄生式间接层」，请把它扔掉。

## 重构与性能`Performance`』

`performance` —词被不同的人予以不同的解释和认知：效率、性能、效能。不同地区的习惯用法亦不相同。本书一遇 `performance` 我便译为性能。`effcient` 译为高效，`effective` 译为有效。

重构可以帮助我写出更快的软件。短程看来，重构的确会使软件变慢，但它使优化阶段中的软件性能调整更容易。最终我还是有赚头。

