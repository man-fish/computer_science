## 算法效率的度量方法

**事后统计方法**

这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

**事前分析估算方法**

在计算机程序编写前，依据统计方法对算法进行估算。

经过总结，我们发现一个高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

1. 算法采用的策略，方案
2. 编译产生的代码质量
3. 问题的输入规模
4. 机器执行指令的速度

> 由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。（所谓的问题输入规模是指输入量的多少）

## 时间复杂度

#### 定义：

在进行算法分析时，主语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：`T(n)= O(f(n))`。

它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

用大写O来体现算法时间复杂度的记法，我们称之为大O记法。

**推导大O阶方法**

如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？

- 用常数1取代运行时间中的所有加法常数。
- 在修改后的运行次数函数中，只保留最高阶项。
- 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
- 得到的最后结果就是大O阶。

#### 常数阶

第一条就说明了所有加法常数给他个O(1)即可

```cpp
int sum = 0, n = 100;
printf(“I love you.com\n”);
printf(“I love you.com\n”);
printf(“I love you.com\n”);
printf(“I love you.com\n”);
printf(“I love you.com\n”);
printf(“I love you.com\n”);
sum = (1+n)*n/2;
```

#### 线性阶：

一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。

```cpp
int i , n = 100, sum = 0;
for( i=0; i < n; i++ )
{
    sum = sum + i;
}
```

`n*2 = n`，我们用常数1取代循环内部的加法常数。

```java
int i , n = 100, sum = 0;
for( i=0; i < n; i++ )
{
    sum = sum + i;
  	printf(sum)
}
```

#### 平方阶

n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。

```cpp
int i, j, n = 100;
for( i=0; i < n; i++ )
{
    for( j=0; j < n; j++ )
    {
        printf(“I love FishC.com\n”);
    }
}
```

> n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。

```cpp
int i, j, n = 100;
for( i=0; i < n; i++ )
{
    for( j=i; j < n; j++ )
    {
        printf(“I love FishC.com\n”);
    }
}
```

- n+(n-1)+(n-2)+…+1 = n(n+1)/2
- n(n+1)/2 = n^2/2+n/2

用我们推导大O的攻略，第一条忽略，因为没有常数相加。第二条只保留最高项，所以n/2这项去掉。第三条，去除与最高项相乘的常数，最终得O(n^2)。

#### 对数阶

由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。于是由2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。

```cpp
int i = 1, n = 100;
while( i < n )
{
    i = i * 2;
}
```

#### 总结

常用的时间复杂度所耗费的时间从小到大依次是：
**O(1) < O(logn) < (n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)**

#### 最坏情况与平均情况

我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么时间复杂度为O(n)。

- 平均运行时间是期望的运行时间。
- 最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，**我们提到的运行时间都是最坏情况的运行时间。**

## 算法的空间复杂度

#### 定义：

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

空间复杂度的计算规则和时间复杂度大同小异。

#### 常数阶

忽略掉常数项，空间复杂度为O(1)

```go
i := 0
j := 0
fmt.Println(i)
fmt.Println(j)
```

#### 线性阶

一个数组的空间复杂度一般是 O(n) 。

```go
arr := make([]int, n)
fmt.Println(arr)
```

#### 平方阶

矩阵的空间复杂度是O(M*N) 或者是O(N^2)

```go
arr := make([][]int, n)
for i :=range arr {
  arr[i] = make([]int, n)
}
fmt.Println(arr)
```

#### 总结

常用的空间复杂度所耗费的时间从小到大依次是：**O(1) < O(n) <  O(n^2) < O(n^3)**

## 最后

通常，我们都是用“时间复杂度”来指运行时间的需求，是用“空间复杂度”指空间需求。当直接要让我们求“复杂度”时，通常指的是时间复杂度。显然对时间复杂度的追求更是属于算法的潮流！