## 龙鸣乘法

在很久很久以前。。。人们是这样做乘法的。。。这是一种古老的乘法算法，但是在如今的计算机中却还能发现它的身影。它，就是以俄罗斯农民命名的乘法算法！

我们绝大多数人学的都是这样做大数字乘法的：

```go
	  86
x   57
------
	 602
+ 4300
------
	4902
```

如果你懂得乘法算式，那么这种“长式相乘”的方法是快速和相对简单的。不过，还有许多其它的计算方法。其中之一通常被称之为俄罗斯农民算法。使用它时不需要你懂得乘法算式，你只需要将数字加倍，减半再进行合计。具体规则如下：

1. 把每一个数字分别写在列头。
2. 将头一列的数字加倍，将第二列的数字减半，如果在第二列的数字是奇数，将它除以二并把余数去掉。
3. 如果第二列的数字是偶数，将其所在行删除。
4. 继续加倍、减半和删除直到第二列的数字为1。
5. 将第一列中剩余的数字相加。于是就得出了根据原始数字计算出的结果。

```js
// 以计算57乘以86为例。
       57     86 ×
      114     43
      228     21
      456     10 ×
      912      5
     1824      2 ×
  +  3648      1
  --------------
     4902
```

真实的俄罗斯农民们可能会用好几碗的鹅卵石来记录他们加倍的数字，用来代替写在列里面的数字。（当然，他们或许不会对我们的例子里那么大的数字感兴趣，要知道四千多个鹅卵石可是很难操作的哟！）俄罗斯的农民们并不是唯一使用这种算法的人，在数千年之前古埃及人就已经发明了类似的方法，而同时在今天的计算机中仍然在使用与之相关的程序。

## 龙鸣乘法的应用

在计算机中除`2`与乘`2`的操作是很快的，用位运算就可以了，而且对于很大的数来讲，这种方法也是可行的，因为对这种算法讲，`m`是以指数下降的，即使一个`32`位才能表示的整数也只要移位`31`次就可以为`1`，在机器层面讲，乘法是比移位慢的多的操作。

所以，这个方法经常被用于两数相乘取模的场景，如果两数相乘已经超过数据范围，但取模后不会超过，我们就可以利用这个方法来拆位取模计算贡献，保证每次运算都在数据范围内，下面是该算法的`go`语言实现。

```go
func quickMulti(A, B int) int {
	ans := 0
	for ; B != 0; B >>= 1 {
		if B & 1 == 1 {
			ans += A
		}
		A <<= 1
	}
	return ans
}
```

## 例题：求1+2+…+n？

求 `1`+`2`+...+`n` ，要求不能使用乘除法、`for`、`while`、`if`、`else`、`switch`、`case`等关键字及条件判断语句（`A ? B : C`）。

**示例 1：**

```js
输入: n = 3
输出: 6
```

**示例 2：**

```js
输入: n = 9
输出: 45
```

**解答：**

1 + ... + n

```go
func sumNums(n int) int {
	ans := 0
	qm(n, n+1, &ans)
	return ans >> 1
}

func qm(a, b int, ans *int) bool {
	cond := b&1 > 0

	addGreatZero := func() bool {
		*ans += a
		return *ans > 0
	}

	_ = cond && addGreatZero()
	a <<= 1
	b >>= 1

	_ = (b != 0) && qm(a, b, ans)
	return true
}
```

