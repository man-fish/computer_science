## 二叉搜索矩阵

回忆一下前面二叉搜索树的特性：

- 若二叉搜索树的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若它的右子树不空，则右子树上所有节点的值均大于其根节点的值。

而现在我们有一个 `n * m` 的二维数组，其每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序：

```ts
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

乍一看和二叉搜索树没有任何关系，但是如果我们将矩阵逆时针旋转 `45`° ，并将其转化为图形式，发现其类似于二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。

![Picture1.png](assets/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

因此对于目标数 `target`，通过从 “根节点” 开始搜索，遇到比 `target` 大的元素就向左，反之向右，即可找到 `target` 。

“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，称之为 标志数 ，以 `matrix` 中的 左下角元素 为标志数 `flag` ，则有:

+ 若 `flag >` `target` ，则 `target` 一定在 `flag` 所在 行的上方 ，即 `flag` 所在行可被消去。
+ 若 `flag <` `target` ，则 `target` 一定在 `flag` 所在 列的右方 ，即 `flag` 所在列可被消去。

> [注:]()在查找范围不断缩小的过程中，标志数也在不断的改变，类似于二叉搜索树中每次选择的顶点。

### 搜索

那么在二叉搜索矩阵中查找的代码当然不难写出：

1. 从矩阵 `matrix` 左下角元素（索引设为 `(i, j)` ）开始遍历，并与目标值对比：
   + 当 `matrix`[`i`][`j`] `> target` 时，执行 `i--` ，即消去第 `i` 行元素；
   + 当 `matrix`[`i`][`j`] `< target` 时，执行 `j++` ，即消去第 `j` 列元素；
   + 当 `matrix`[`i`][`j`] `= target` 时，返回 `true` ，代表找到目标值。

2. 若行索引或列索引越界，则代表矩阵中无目标值，返回 `false` 。

每轮 `i` 或 `j` 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引`(i,j)` 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。

> [复杂度分析：]()
>
> 时间复杂度 `O(M+N)` ：其中，`N` 和 `M` 分别为矩阵行数和列数，此算法最多循环 `M`+`N` 次。
>
> 空间复杂度 `O(1)` : `i, j `指针使用常数大小额外空间。

