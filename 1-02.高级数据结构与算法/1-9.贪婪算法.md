# 贪心算法

**贪心算法**（英语：`greedy algorithm`），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最优（局部最优）的选择，从而希望导致结果是最优（全局最优）的算法。

比如你面前放着 `100` 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

**例子**:最小生成树的算法 `(Prim MST、Kruskal MST、Dijkstra's algorithm)`。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。所以贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

贪心算法与[动态规划](https://zh.wikipedia.org/wiki/动态规划)的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

**注意**：贪心算法每一步都要选择当前子状态的最优解，所以说一般要对已知量进行排序，所以排序对于贪心算法效率影响极大。

## 贪心选择性

贪心算法并不难在使用而是难在证明上,想要证明一个问题可以使用贪心算法我们可以从两个角度出发:

1. 举反例证明贪心算法是错误的。
2. 反证法:假设贪心算法为 `A`;最优算法为 `O`,发现 `A` 能完全代替 `O`,并且不影响求出最优解。

### 最优证明方法：Exchange Argument交换变量证明法

`Exchange Argument`的主要的思想也就是先假设存在一个最优的算法和我们的贪心算法最接近，然后通过交换两个算法里的一个步骤(或元素)，得到一个新的最优的算法，同时这个算法比前一个最优算法更接近于我们的贪心算法，最优只能有一个，从而得到矛盾，证明所谓的最优算法非最优，原命题成立。

#### 步骤：

**Step0**：给出贪心算法`A`的描述

**Step1**：假设`O`是和`A`最相似**(假设`O`和`A`的前`k`个步骤都相同，第`k+1`个开始不同，通常这个临界的元素最重要)**的最优算法

**Step2**： **`[Key]`** 修改算法`O`**(用`Exchange Argument`，交换`A`和`O`中的一个元素)**，得到新的算法`O’`。

**Step3**： 证明`O’` 是**feasible**（可行的）的，也就是`O’`是对的。

**Step4**： 证明`O’`至少和`O`一样，即`O’`也是最优的

**Step5**：得到矛盾，因为`O’` 比`O` 更和`A` 相似，证毕。

https://blog.csdn.net/zhuzhi123zhuzhi/article/details/52751711

## Interval Scheduling 区间调度类型问题

给你很多形如 `[start, end]` 的闭区间，请你设计一个算法，**算出这些区间中最多有几个互不相交的区间**。

```java
int intervalSchedule(int[][] intvs);
```

举个例子，`intvs = [[1,3], [2,4], [3,6]]`，这些区间最多有 2 个区间互不相交，即 `[[1,3], [3,6]]`，你的算法应该返回 2。注意边界相同并不算相交。

这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 `[start, end]` 表示开始和结束的时间，请问你今天**最多能参加几个活动呢**？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。

这类问题的正确的思路其实很简单，可以分为以下三步：

1、从区间集合 `intvs` 中选择一个区间 `x`，这个 `x` 是在当前所有区间中**结束最早的**（`end` 最小）。

2、把所有与 `x` 区间相交的区间从区间集合 `intvs` 中删除。

3、重复步骤 1 和 2，直到 `intvs` 为空为止。之前选出的那些 `x` 就是最大不相交子集。

### Maximum Cardinality Disjoint Interval Problem 最小无交叉时间段集合

问题描述：给一些时间片段集合`T={（a1，b1）（a2，b2），。。。，（an，bn）}`，找出一个元素**个数最多**的子集`S`，子集中的每个元素的时间片段没有交叉。

#### Greedy Algorithm 贪婪算法

每次都选所有`interval` 中bi最小的那个，把`（ai，bi）`加入`S`，然后把`（ai，bi）`在`T`中删除，同时把T中所有和`（ai，bi）`有交叉的`interval`删除，然后再在`T`中找最小的`bj`，循环上面的操作，直到没有可以在添加的。

```ts
func eraseOverLappingIntervalGreedily(intervals []interval) int {
	IntervalBubbleSortByback(intervals)
	//按区间最后位置大小升序排序。
	if len(intervals) == 0 {
		return 0
	}

	pre := 0
	res := 1

	for i := 1; i < len(intervals); i++ {
		if intervals[pre][1] < intervals[i][0] {
			res++
			pre = i
		}
	}

	return res
}
//intervals := []interval{[2]int{3,5},[2]int{3,4},[2]int{1,2}}
```

#### Exchange Argument交换变量证明

我们的`Greedy Algorithm`记为`A`，假设`A`不是最优的，那么就一定存在一个`O`，`O`是和`A`最相近的一个最优的算法，`最相近是指和O和A的前K-1个选择都相同，第K个是不同的`。**也就是说这个问题的最优解是`n`，而我们这个选择得到的解最多为`n-1`。**

假设对于`A`，`A`第`k`个选择的是`（ai，bi）`；而`O`第`K`个选择的是`（aj，bj）`。从`A`的定义我们可以直到，`bi<=bj`。

现在我们构造一个**O'，`O' = O-（aj，bj）+（ai，bi）`。**这里我们指代为用`A`的`ai,bi`代替`o`的`aj,bj`。

**1）很显然，O'是这个问题的一个解，也就是说O'中的`intervals`没有重叠的。**

因为`O`算法和`A`算法在前`k-1`和选择是是没有去别的，所以在`O'`中，`（ai，bi）`前的`intervals`和A中的一样，所以前一部分没有重叠。在`（ai，bi）`后的`intervals`和`O`中的一样，因为`bi<=bj`，`（ai，bi）`也不会和它相邻的重叠，所以`（ai，bi）`后的`intervals`也没有重叠，所以`O'`中的所有`intervals`都没有重叠。

**2）`O'`是一个最优解，因为他的`intervals`的个数和O一样。**

综上，我们找到了一个最优解`O'`，它由`O`与`A`交换第`k`个变量而来，和`A`具有的共同的`intervals`有K个，这和我们前提假设最多有`k-1`个相矛盾，所以，`A`是最优的。证毕。

## Assign Cookies 分发饼干

假设你是一个很棒的父母，并希望给你的孩子一些饼干。但是，你最多应该给每个孩子一个饼干。每个孩子都有一个贪婪指数`g(i)`，这是指一个饼干的最小大小。孩子将满足：每个 `cookie j` 都有一个大小 `s(j)`。如果 `sj >= gi，`我们可以将 `cookie j` j分配给孩子 i，孩子就会很开心。你的目标是求出最多开心孩子的数目。

### Greedy Algorithm 贪婪算法

每一次都选择最大块`cookie`分发个最贪婪的小朋友。

```ts
func feedContentChildren(g []int, s []int) int {
	sort.BubbleSort(g)
	sort.BubbleSort(s)

	var si, gi,res int
	for si < len(s) && gi < len(g) {
		if s[si] >= g[gi] {
			res++
			si++
			gi++
		}else{
			gi++
		}
	}
	return res
}
```

### Exchange Argument交换变量证明

我们的`Greedy Algorithm`记为`A`，假设`A`不是最优的，那么就一定存在一个`O`，`O`是和`A`最相近的一个最优的算法，`最相近是指和O和A的前K-1个选择都相同，第K个是不同的`。**也就是说这个问题的最优解是`n`，而我们这个选择得到的解最多为`n-1`。**

假设对于`A`，`A`第`k`个选择的是`cookie i`；而`O`第`K`个选择的是`cookie j`。从`A`的定义我们可以直到，`w[i] > w[j]`。

现在我们构造一个**O'，`O' = O- w[j]+ w[i]`。**

**1）很显然，O'是这个问题的一个解，也就是说O'中的孩子都很满足。**

因为`O`算法和`A`算法在前`k-1`和选择是是没有区别的，而`w[i] > w[j]`所以第`k`个孩子一定被满足。

**2）`O'`是一个最优解，因为`w[i] > w[j]`第k个孩子甚至更满足。**

综上，我们找到了一个最优解`O'`，它由`O`与`A`交换第`k`个变量而来，和`A`具有的共同的满足孩子数有K个，这和我们前提假设最多有`k-1`个相矛盾，所以，`A`是最优的。证毕。



