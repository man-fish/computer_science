# 区间模型

所谓区间 `dp`，顾名思义就是在一段区间上的动态规划。它既要满足dp问题的最优子结构和无后效性外，还应该符合在区间上操作的特点。

区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。令状态 `f(i, j)` 表示将下标位置 到 的所有元素合并能获得的价值的最大值，那么 `f(i, j) = max(f(i, k) + f(k + 1, j) + cost)}` ， `cost`为将这两组元素合并起来的代价。

我的理解是往往会对区间进行合并操作。抑或是单个元素（可看成一个小区间）跨区间进行操作。例如括号匹配问题，石子合并问题（通过多次的相邻合并，最后实质上会产生跨区间的合并，如果你把其中的石子看作参考系的话就很容易感觉出来），还有在整数中插入运算符号的问题（利用运算符的优先级以及交换律可看出），这样以来，如果我们要得知一个大区间的情况，由于它必定是由从多个长度不一的小区间转移而来（转移情况未知），我们可以通过求得多个小区间的情况，从而合并信息，得到大区间。

> **对于一个长度为n的区间，确定它的子区间需要首尾两个指针，显然子区间数量级为n2，那区间dp的复杂度也就为n2**。

区间 `DP` 的特点：

**合并**：即将两个或多个部分进行整合，当然也可以反过来；

**特征**：能将问题分解为能两两合并的形式；

**求解**：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。

## 动规范式

由于计算 `f(i, j)` 的值时需要知道所有 `f(i, k)` 和 `f(k+1, j)` 的值，而这两个中包含的元素的数量都小于 `f(i, j)`，所以我们以 `len = j - i + 1` 作为 DP 的阶段。首先从小到大枚举 `len`，然后枚举 `i` 的值，根据 `len` 和 `i` 用公式计算出`j` 的值，然后枚举 `k`，时间复杂度为 `O(n^3)`。

```go
for len := 1; len <= n; len++ {		
  // 枚举区间长度；
	for i := 0; i < n ; i++ {
    // 枚举起点，从 0 开始到 n - len;
    j := i + len -1
    // 计算终点坐标;
    if j >= n {
      break
    }
    for k := i; k < j; k++ {		
      // 枚举区间分割点
      dp[i][j] = max{dp[i][k] + dp[k + 1][j] + costOfMerge}
    }
	}
}
```

## 石子合并问题

有`N`堆石子排成一排，每堆石子有一定的数量。现要将`N`堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过`N-1`次合并后成为一堆。求出总的代价最小值。

#### 策略设计

区间 `dp` 的第一步便是找出最外层区间的起点和终点，对于这道题来说自然是第一个石块和最后一个石块，确定区间之后我们需要计算合并区间的代价，对于这道题来说不论一个区间内以哪点作为分界，合并的代价都是整个区间内的石块重量和。

可是如果每次合并的时候都计算一遍石块重量和(`w[i] +...+w[j]`)，这样带来的消耗会很大，所以这里我们使用一个巧妙的数据结构 — `sums` 数组，`sums[i]` 表示 `w[0] +... +w[i]`的值，这样计算 `w[i] +...+w[j]` 就等于 `sums[j] - sum[i-1]`。由此明确了区间的界限和合并的消耗，状态转移方程可以轻松得出：
$$
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+ sum[j] - sum[i-1]);
$$

#### 算法实现

实际实现这个算法的时候我们给 `sums` 数组加额外的一位，`sum[0]`表示前 `0` 个石子的重量和，这样可以避免掉很多边界值情况，之后我们套用上面的编程范式便可以写出区间规划的解法：

```ts
function mergeStone(stones: number[]) {
    let n = stones.length;
    let dp = new Array(n);
    for (let i = 0; i < n; i++) {
        dp[i] = new Array(n).fill(0);
    }

    let sums = new Array(n + 1).fill(0);
    for (let i = 1; i < n + 1; i++) {
        sums[i] = stones[i - 1] + sums[i - 1];
    }

    for (let l = 2; l <= n; l++) {
        for (let i = 0; i < n; i++) {
            let j = i + l - 1;
            if (j >= n) {
                continue;
            }
            for (let k = i; k < j; k++) {
                if (dp[i][j] === 0) {
                    dp[i][j] = dp[i][k] + dp[k + 1][j] + sums[j + 1] - sums[i];
                } else {
                    dp[i][j] = Math.min(
                        dp[i][j],
                        dp[i][k] + dp[k + 1][j] + sums[j + 1] - sums[i]
                    );
                }
            }
        }
    }
    return dp[0][n - 1];
}
```

## [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

#### 策略设计

![image-20200602192200464](assets/image-20200602192200464.png)

#### 算法实现

`dp[i+1][j-1]`位于`dp[i][j]`的左下，所以我们必须列遍历，刚好这复合区间dp的通用范式，之后就没有什么好说的了:

```js
func longestPalindrome(s string) string {
	n := len(s)
	dp := make([][]int, n)
	for idx := range dp {
		dp[idx] = make([]int, n)
	}

	ans := ""
	for l := 0; l < n; l++ {
		for i := 0; i+l < n; i++ {
			j := i + l
      // do somthing...
			if l == 0 {
				dp[i][j] = 1			// 防止只有一位。
			} else if l == 1 {	// 跨度为一直接判断两端是否相等。
				if s[i] == s[j] {
					dp[i][j] = 1
				}
			} else {
				if s[i] == s[j] {
					dp[i][j] = dp[i+1][j-1]
				}
			}
			if dp[i][j] > 0 && l+1 > len(ans) {	// 判断是否为最长
				ans = s[i: j+1]
			}
      // ...
		}
	}
	return ans
}
```

