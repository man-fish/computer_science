## Rabin-Karp

-------

`Rabin-Karp` 算法是一种基于散列的字符串查找算法，其创始人一个叫罗宾 `M.O.Rabin` 和一个叫卡普 `R.A.Karp`。

#### 算法来源

通常情况下，基于散列的字符串查找步骤是：

1. 首先计算模式字符串的散列函数；
2. 然后利用相同的散列函数计算文本中所有可能的 `M` 个字符的子字符串的散列函数值并寻找匹配；

这种算法看起来很美妙，但实际上比暴力查找还慢，因为计算散列值会涉及字符串中的每个字符。而`Rabin` 和 `Karp` 对上述方法进行了改进，发明了一种能够在**常数时间**内算出 `M` 个字符的子字符串散列值的方法。

#### 算法原理

选择一个合适的哈希函数很重要。假设文本串为`t[0, n)`，模式串为`p[0, m)`，其中 `0<m<n`，`Hash(t[i, j])` 代表字符串 `t[i, j]` 的哈希。

当 `Hash(p[0, m-1]) != Hash(t[0, m-1])` 的时候，我们很自然的会把 `t[1, m]` 拿来继续比较，在这个过程中，若我们重新计算字符串`t[1, m]`的哈希值，这个过程中如果我们重新计算它的 `hash` 值，则我们还需要 `O(m)` 的时间复杂度，时间复杂度会爆表。观察到字符串`t[0, m-1]`与`t[1, m]`中有 `m-1` 个字符是重合的，因此我们可以选用**滚动哈希函数**，那么重新计算的时间复杂度就降为 `O(1)`。

`Rabin-Karp` 算法选用的滚动哈希函数利用 [Rabin fingerprint](https://en.wikipedia.org/wiki/Rabin_fingerprint) 的思想，举个例子，计算字符串`t[0, m - 1]`的哈希值的公式如下:
$$
Hash(t[0,m−1])=t[0]∗b_{m−1}+t[1]∗b_{m−2}+...+t[m−1]∗b_0
$$
其中的 `b` 是一个常数，在 `Rabin-Karp` 算法中，我们一般取值为 `256`，因为一个字符的最大值不超过 `255`。上面的公式还有一个问题，哈希值如果过大可能会溢出，因此我们还需要对其取模，这个值应该尽可能大，且是质数，这样可以减小哈希碰撞的概率，在这里我们就取 `101`。

则计算字符串`t[1, m]`的哈希值公式如下，
$$
Hash(t[1,m])=(~Hash(t[0,m−1])~−~t[0]∗b_{m−1})~∗~b~+~t[m]∗b_0
$$









![img](assets/10462182-c19ce45e3ae9f53f-20201119144007474.png)

