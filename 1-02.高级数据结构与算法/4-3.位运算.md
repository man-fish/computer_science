## 位运算基础

**位操作**是[程序设计](https://zh.wikipedia.org/wiki/程序设计)中对[位模式](https://zh.wikipedia.org/w/index.php?title=位模式&action=edit&redlink=1)或[二进制数](https://zh.wikipedia.org/wiki/二進位數)的一元和二元操作。在许多古老的[微处理器](https://zh.wikipedia.org/wiki/微处理器)上，位运算比加减运算略快，通常位运算比乘除法运算要快很多。在现代架构中，情况并非如此：位运算的运算速度通常与加法运算相同（仍然快于乘法运算）。![image-20200622132032633](http://image.innoweb.cn/2020-06-25-132036.png)

基本的位操作符有与、或、异或、取反、左移、右移`6`种，这`6`种操作符，`~`取反是单目操作符，其它`5`种都是双目操作符：

| 运算符 | 解释                                                                            |
| ------ | ------------------------------------------------------------------------------- |
| `&`    | 只有两个对应位都为 1 时才为 1                                                   |
| `|`    | 只要两个对应位中有一个 1 时就为 1                                               |
| `^`    | 只有两个对应位不同时才为 1                                                      |
| `~`    | 0变1，1变0                                                                      |
| `<<`   | 各二进位全部左移若干位，高位丢弃，低位补0                                       |
| `>>`   | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样。 |

位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像`1，3，5，9`这些`2^i+1`的数字。写成`int a = 1 << i + 1`是不对的，程序会先执行`i + 1`，再执行左移操作。应该写成`int a = (1 << i) + 1`。

> **注意：**位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。

#### 取反 `NOT`

**取反**是一元运算符，对一个二进制数的每一位执行逻辑[反](https://zh.wikipedia.org/wiki/反)操作。使数字1成为0，0成为1。例如：

```
NOT 0111（十进制7）
  = 1000（十进制8）
```

许多程序设计语言，取反操作符用波浪线"`~`"表示。值得注意的是此操作符与"逻辑非（`!`）"操作符不同。"逻辑非"并不是一个位操作。

#### 按位或 `OR`

**按位或**处理两个长度相同的二进制数，两个相应的二进位中只要有一个为1，该位的结果值为1。例如

```
   0101（十进制5）
OR 0011（十进制3）
 = 0111（十进制7）
```

在C类程序设计语言中，按位或操作符是"|"。这一操作符需要与逻辑或运算符（||）区别开来。

#### 按位异或 `XOR`

**按位异或**运算，对等长二进制模式或二进制数的每一位执行逻辑异或操作。操作的结果是如果某位不同则该位为1，否则该位为0。例如

```
    0101
XOR 0011
  = 0110
```

在类C语言中，按位异或运算符是"`^`"，将下面`A`和`B`的二进制表示的每一位进行异或操作：

```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
```

从上面这些结果中可以总结出，异或操作也就是`不进位加法`，比如1 + 1 = 10， 我们只取个位，不要进位的那个1，其他同理。

#### 按位与 `AND`

按位与处理两个长度相同的二进制数，两个相应的二进位都为1，该位的结果值才为1，否则为0。例如：

```
    0101
AND 0011
  = 0001
```

在类C语言中，按位与用'&'表示

#### 移位 `<< >>`

**`<<` 左移运算** ，向左进行移位操作，高位丢弃，低位补 0，如

```c
int a = 8;
a << 3;
移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位后：0000 0000 0000 0000 0000 0000 0100 0000
```

**`>>` 右移运算**，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如

```c
unsigned int a = 8;
a >> 3;
移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位后：0000 0000 0000 0000 0000 0000 0000 0001

int a = -8;
a >> 3;
移位前：1111 1111 1111 1111 1111 1111 1111 1000
移位前：1111 1111 1111 1111 1111 1111 1111 1111
```

## 与`&`运算技巧
`&`运算可以用来消去二进制中的某一位，`x & (x - 1)` 用于消去`x`最后一位的1, 比如`x = 12`, 那么在二进制下就是`1100`

```js
x           = 1100
x - 1       = 1011
x & (x - 1) = 1000
```

当然`&`运算也可用来判断奇偶数：

```go
return 0 == (a & 1)
```

#### 技巧一：O(*1*) 时间检测整数 n 是否是 2 的幂次

N如果是2的幂次，则N满足两个条件：

- N > 0
- N的二进制表示中`只有一个1`, 有多个那叫`2的倍数`。

因为`N`的二进制表示中只有一个`1`，所以使用`N & (N - 1)`将N唯一的一个`1`消去，应该返回`0`，下面是`golang`的代码实现，注意运算符优先级。

```go
func isPowerOfTwo(n int) bool {
    return n > 0 && n & (n-1) == 0 
}
```

> [leetcode - 231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)

#### 技巧一拓展：O(*1*) 时间检测整数 *n* 是否是 4 的幂次

```ts
//   0 1 0 1 0 1 0 1
//    64  16   4   1
// -----------------
function isPowerOfFour(num: number): boolean {
    return (
        num > 0 && // is positive.
        (num & (num - 1)) === 0 && // is power of 2.
        (num & 0x55555555) === num // is power of 4.
    )
}
```

> [leetcode - 342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

#### **技巧二： *32* 位的整数的二进制中有多少个 *1***

由`x & (x - 1)`消去x最后一位的1可知。不断使用 `x & (x - 1) `消去`x`最后一位的1，计算总共消去了多少次即可。

```go
func countOne(num uint32) int {
    count := 0
    for num != 0 {
        num = num & (num-1)
        count++
    }
    return count
}
```

其实计算二进制中有多少个 `1` 也可以不使用 `&` 运算，不过这是 `javascript` 语言本身的特性：

```ts
function bitCount(num: number): number {
    return num.toString(2).split('0').join('').length
}
```

> [leetcode - 191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

#### 技巧三：如果要将整数 A转换为 B，需要改变多少个bit位？

整数A转换为B，如果A和B在第`i（0 <=i < 32）`个位上相等，则不需要改变这个BIT位，如果在第i位上不相等，则需要改变这个BIT位，所以问题转化为了A和B有多少个BIT位不相同，那么直接使用异或运算，可以得出所有不同的位，之后计算1的个数即可。

```go
func bitSwapRequired(a, b uint32) int {
  return countOne(a^b)
}
```

## 异或`^`运算技巧
------
对于异或运算，首先我们要知道异或运算有以下三个性质：
$$
a⊕0=a
$$

$$
a⊕a=0
$$

$$
a⊕b⊕a=b⊕(a⊕a)=b⊕0=b
$$

最后还有一个特性就是我们上面提到过的，异或等于`无进位加法`。

#### **技巧一：无额外变量的值交换**

不需要额外变量的值交换，下面是这个技巧的代码实现：

```js
a = a^b
b = a^b
a = a^b
```

这个技巧运用了性质三`a ⊕ b ⊕ a=b ⊕ (a ⊕ a)=b`，也就是交换律和性质一、性质二结合，下面是详细的推导过程：

```js
						| a					| b
------------+-----------+----------
step one		| a^b				| b
step two		| a^b				| b^(a^b)=a
step three	| a^(b^a)=b	| a
```

#### **技巧二：无加号加法**

无加号加法，给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符：

```js
输入: 1,2
输出: 3
```

这个算法主要利用异或运算来完成，异或运算有一个别名叫做：`不进位加法`，`a ^ b`就是`a`和`b`相加之后，该进位的地方不进位的结果，而如果我们想要用它实现真正的加法，给`a`和`b`里都是1的地方进位操作，`a&b`能让我们找出都为一的地方，那么这些位置`左边`都应该有一个进位1，`a & b << 1` 就是`进位的数值`。

```js
a + b = (a ^ b) + (a & b << 1)
```

可我们不能使用中间的这个加号，所以我们令`a' = a ^ b, b' = (a & b) << 1` => `a = a', b = b'`，然后反复迭代，这个过程是在二进制下模拟加法的运算过程，进位不可能一直持续，`b`最终会变为`0`，也就是没有需要进位的了，因此重复做上述操作就可以最终求得`a + b`的值。

```go
func add(a int, b int) int {
    for b != 0 {
        sum := a ^ b
        carry := (a & b) << 1

        a = sum
        b = carry
    }
    return a
}
```

> [leetcode - 371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

#### **技巧三：只出现一次的数字**

数组中只有一个数出现一次，剩下都出现两次，找出出现一次的数，其实这是LeetCode上的一道算法题[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)。

```go
输入: [2,2,1]
输出: 1
```

对于这道题我们知道`a ^ b ^ b = a` 所以只要将所有的数异或起来，就可以得到唯一的那个数，因为相同的数出现的两次，异或两次等价于没有任何操作。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let num = 0
    nums.forEach(item => {
        num = num ^ item
    })
    return num
};
```

> [leetcode - 136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

#### **技巧三：只出现一次的数字 [II](https://leetcode-cn.com/problems/single-number-ii/)**

数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数？

```js
输入: [2,2,3,2]
输出: 3
```

如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 *3* 的倍数，因此，统计所有数字的各二进制位中 *1* 的出现次数，并对 *3* 求余，结果则为只出现一次的数字。

![image-20200622150916409](http://image.innoweb.cn/2020-06-25-132028.png)

各二进制位的**位运算规则相同**，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0, 1, 2。

- 若输入二进制位 11 ，则状态按照以下顺序转换。
- 若输入二进制位 00 ，则状态不变。

$$
0→1→2→0→⋯
$$

![image-20200622151157802](http://image.innoweb.cn/2020-06-25-132023.png)

如下图所示，由于二进制只能表示 0, 10,1 ，因此需要使用两个二进制位来表示 33 个状态。设此两位分别为`two , one` ，则状态转换变为：

$$
00→01→10→00→⋯
$$
![image-20200622151355472](http://image.innoweb.cn/2020-06-25-132019.png)

接下来，需要通过 状态转换表 导出 状态转换的计算公式 。首先回忆一下位运算特点，对于任意二进制位 x，有：

- 异或运算：`x ^ 0 = x ， x ^ 1 = ~x`
- 与运算：`x & 0 = 0 ， x & 1 = x`

设当前状态为`two one `，此时输入二进制位 `n` 。如下图所示，通过对状态表的情况拆分，可推出` one `的计算方法为：

```
if two == 0:
  if n == 0:
    one = one
  if n == 1:
    one = ~one
if two == 1:
    one = 0
```

引入 **异或运算** ，可将以上拆分简化为：

```js
if two == 0:
    one = one ^ n
if two == 1:
    one = 0
```

引入 **与运算** ，可继续简化为：

```js
one = one ^ n & ~two
```

![image-20200622153133875](http://image.innoweb.cn/2020-06-25-132014.png)

由于是先计算 one ，因此应在新 one 的基础上计算 two 。
如下图所示，修改为新 oneone 后，得到了新的状态图。观察发现，可以使用同样的方法计算 two ，即：

```js
two = two ^ n & ~one
```

![image-20200622153242099](http://image.innoweb.cn/2020-06-25-132011.png)

以上是对数字的二进制中 “一位” 的分析，而 int 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。

遍历完所有数字后，各二进制位都处于状态 00 和状态 01 （取决于 “只出现一次的数字” 的各二进制位是 11 还是 00 ），而此两状态是由 one 来记录的（此两状态下 twos 恒为 00 ），因此返回 ones 即可。

```js
class Solution {
    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num : nums){
            ones = ones ^ num & ~twos;
            twos = twos ^ num & ~ones;
        }
        return ones;
    }
}
```

> [leetcode - 137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)
>
> **解法摘自：** https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/

## 取非运算技巧 `~`
#### 技巧一：位操作交换符号

交换符号将正数变成负数，负数变成正数。

**原理：**整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

```js
int reversal(int a) {
  return ~a + 1;
}
```

> **注意：**如果说负数是范围最小值的时候，使用该方法仍然得到该负数。

## 移位运算技巧 `<< >>`
移位运算可以实现乘除法，数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2

```java
int a = 2;
a >> 1; ---> 1
a << 1; ---> 4
```

#### 技巧一：求绝对值

整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其`符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff）`，然后根据符号进行相应的操作

```go
var c int8 = -128
fmt.Println(c >> 7)

int abs(int a) {
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
```

上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)

```c
int abs2(int a) {
  int i = a >> 31;
  return ((a^i) - i);
}
```

#### 技巧二：无符号数高低位交换

给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：

```go
34520的二进制表示：
10000110 11011000

将其高8位与低8位进行交换，得到一个新的二进制数：
11011000 10000110
其十进制为55430
```

只要将无符号数 a>>8 即可得到其高 8 位移到低 8 位，高位补 0；将 a<<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>>8 和 a<<8 进行或操作既可求得交换后的结果。

```c
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```

#### 技巧三：无符号数逆序

将无符号数的二进制表示进行逆序，求取逆序后的结果，如

```text
数34520的二进制表示：
10000110 11011000

逆序后则为：
00011011 01100001
它的十进制为7009
```

在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。

- 第一步:以每 2 位为一组，组内进行高低位交换

```text
交换前： 10 00 01 10 11 01 10 00
交换后： 01 00 10 01 11 10 01 00
```

- 第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换

```text
交换前： 0100 1001 1110 0100
交换后： 0001 0110 1011 0001
```

- 第三步：以每 8 位为一组，组内高低位进行交换

```text
交换前： 00010110 10110001
交换后： 01100001 00011011
```

- 第四步：以每16位为一组，组内高低位进行交换

```text
交换前： 0110000100011011
交换后： 0001101101100001
```

对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：

```text
原数：  10000110 11011000
奇数位： 10000010 10001000
偶数位： 00000100 01010000
```

再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：

```text
原数：  10000110 11011000
奇数位右移一位： 0 10000010 1000100
偶数位左移一位：0000100 01010000 0
两数相或得到： 01001001 11100100
```

上面的方法用位操作可以表示为：

- 取 *a* 的奇数位并用 *0* 进行填充可以表示为：`a & 0xAAAA (1010)`。
- 取 *a* 的偶数为并用 *0* 进行填充可以表示为：`a & 0x5555 (0101)` ，因此，上面的第一步可以表示为：
  `a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1)`
- 同理，可以得到其第二、三和四步为：
  - `a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2)`
  - `a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4)`
  - `a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8)`

```c
unsigned short a = 34520;

a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
```

#### 技巧四：返回所有子集

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

```js
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

思路就是使用一个`正整数`二进制表示的`第i位`是1还是0来代表集合的`第i个数取或者不取`。

所以从`0到2^n-1`总共`2^n`个整数，正好对应集合的`2^n`个子集，我们对这`2^n`个整数进行遍历，并且填入对应的元素。

```go
func subsets(nums []int) [][]int {
	  res := make([][]int, 0)
    n := len(nums)
    
    for i := 0; i < (1 << n); i++ {		// 遍历所有位的可能性。
        subset := make([]int, 0)
        for j := 0; j < n; j++ {			
            if (i & (1 << j)) != 0 {	// 添加当前可能性下所有位对应数组的数。
                subset = append(subset, nums[j])
            }
        }
        res = append(res, subset)
    }
    return res
}
```
