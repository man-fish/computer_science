## 用户态和内核态

------

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。

- **内核态** - `cpu` 可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，`cpu` 也可以将自己从一个程序切换到另一个程序。

- **用户态** - 只能受限的访问内存，且不允许访问外围设备，占用 `cpu` 的能力被剥夺，`cpu` 资源可以被其他程序获取。

## 状态切换

-------

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等。而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作，这时需要一个这样的机制: 用户态程序切换到内核态, 但不能控制在内核态中执行的指令，这种机制叫 **系统调用**, 在 `CPU` 中的实现称之为**陷阱指令** `Trap Instruction`。

他们的工作流程如下:

1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈 `(stack frame)`, 以此表明需要操作系统提供的服务;
2. 用户态程序执行陷阱指令;
3. `CPU` 切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问;
4. 这些指令称之为陷阱 `trap` 或者系统调用处理器 `system call handler`. 他们会读取程序放入内存的数据参数, 并执行程序请求的服务;
5. 系统调用完成后, 操作系统会重置 `CPU` 为用户态并返回系统调用的结果;

#### 运行级别

当一个进程执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（简称为内核态）。此时处理器处于特权级最高的（ `0` 级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态\。即此时处理器在特权级最低的（ `3` 级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。 

内核态与用户态是操作系统的两种运行级别，跟 `intel cpu` 没有必然的联系, `intel cpu` 提供 `Ring0-Ring3` 三种级别的运行模式。`Linux` 使用了 `Ring3`级别运行用户态，`Ring0 `作为内核态，没有使用 `Ring1` 和 `Ring2`。`Ring3` 状态不能访问`Ring0` 的地址空间，包括代码和数据。

`Linux` 进程的 `4GB` 地址空间，`3G-4G` 部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过 `write，send` 等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到 `Ring0`，然后进入 `3GB-4GB`中的内核地址空间去执行这些代码完成操作，完成后，切换回 `Ring3`，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。

至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。

#### 切换原因

**a. 系统调用**

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中 `fork()` 实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 `Linux` 的 `int 80h` 中断。

**b. 异常**

当 `CPU` 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

**c. 外围设备的中断**

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时 `CPU` 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。